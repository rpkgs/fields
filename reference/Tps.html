<!DOCTYPE html>
<!-- Generated by pkgdown: do not edit by hand --><html lang="en"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0"><title>Thin plate spline regression — Tps • fields</title><!-- jquery --><script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js" integrity="sha256-CSXorXvZcTkaix6Yvo6HppcZGetbYMGWSFlBw8HfCJo=" crossorigin="anonymous"></script><!-- Bootstrap --><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/3.4.1/css/bootstrap.min.css" integrity="sha256-bZLfwXAP04zRMK2BjiO8iu9pf4FbLqX6zitd+tIvLhE=" crossorigin="anonymous"><script src="https://cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/3.4.1/js/bootstrap.min.js" integrity="sha256-nuL8/2cJ5NDSSwnKD8VqreErSWHtnEP9E7AySL+1ev4=" crossorigin="anonymous"></script><!-- bootstrap-toc --><link rel="stylesheet" href="../bootstrap-toc.css"><script src="../bootstrap-toc.js"></script><!-- Font Awesome icons --><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.12.1/css/all.min.css" integrity="sha256-mmgLkCYLUQbXn0B1SRqzHar6dCnv9oZFPEC1g1cwlkk=" crossorigin="anonymous"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.12.1/css/v4-shims.min.css" integrity="sha256-wZjR52fzng1pJHwx4aV2AO3yyTOXrcDW7jBpJtTwVxw=" crossorigin="anonymous"><!-- clipboard.js --><script src="https://cdnjs.cloudflare.com/ajax/libs/clipboard.js/2.0.6/clipboard.min.js" integrity="sha256-inc5kl9MA1hkeYUt+EC3BhlIgyp/2jDIyBLS6k3UxPI=" crossorigin="anonymous"></script><!-- headroom.js --><script src="https://cdnjs.cloudflare.com/ajax/libs/headroom/0.11.0/headroom.min.js" integrity="sha256-AsUX4SJE1+yuDu5+mAVzJbuYNPHj/WroHuZ8Ir/CkE0=" crossorigin="anonymous"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/headroom/0.11.0/jQuery.headroom.min.js" integrity="sha256-ZX/yNShbjqsohH1k95liqY9Gd8uOiE1S4vZc+9KQ1K4=" crossorigin="anonymous"></script><!-- pkgdown --><link href="../pkgdown.css" rel="stylesheet"><script src="../pkgdown.js"></script><meta property="og:title" content="Thin plate spline regression — Tps"><meta property="og:description" content='Fits a thin plate spline surface to irregularly spaced data. The 
smoothing parameter is chosen by generalized cross-validation. The assumed 
model is additive  Y = f(X) +e  where f(X) is a d dimensional surface.
This is the classic nonparametric curve/surface estimate pioneered in statistics by Grace Wahba.
This function also works for just a single dimension and is a special case of a Gaussian process estimate as the range parameter in the Matern family increases to infinity. 
(Kriging).
A "fast" version of this function uses a compactly supported Wendland covariance and sparse linear algebra for handling larger datta sets. Although a good approximation to Tps for sufficiently large aRange its actual form is very different from the textbook thin-plate definition.'><!-- mathjax --><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js" integrity="sha256-nvJJv9wWKEm88qvoQl9ekL2J+k/RWIsaSScxxlsrv8k=" crossorigin="anonymous"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/config/TeX-AMS-MML_HTMLorMML.js" integrity="sha256-84DKXVJXs0/F8OTMzX4UR909+jtl4G7SPypPavF+GfA=" crossorigin="anonymous"></script><!--[if lt IE 9]>
<script src="https://oss.maxcdn.com/html5shiv/3.7.3/html5shiv.min.js"></script>
<script src="https://oss.maxcdn.com/respond/1.4.2/respond.min.js"></script>
<![endif]--></head><body data-spy="scroll" data-target="#toc">
    

    <div class="container template-reference-topic">
      <header><div class="navbar navbar-default navbar-fixed-top" role="navigation">
  <div class="container">
    <div class="navbar-header">
      <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar" aria-expanded="false">
        <span class="sr-only">Toggle navigation</span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
      <span class="navbar-brand">
        <a class="navbar-link" href="../index.html">fields</a>
        <span class="version label label-default" data-toggle="tooltip" data-placement="bottom" title="">14.1</span>
      </span>
    </div>

    <div id="navbar" class="navbar-collapse collapse">
      <ul class="nav navbar-nav"><li>
  <a href="../reference/index.html">Reference</a>
</li>
<li class="dropdown">
  <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" data-bs-toggle="dropdown" aria-expanded="false">
    Articles
     
    <span class="caret"></span>
  </a>
  <ul class="dropdown-menu" role="menu"><li>
      <a href="../articles/Tps.html">Tps usage illustration</a>
    </li>
    <li>
      <a href="../articles/fastTps.html">fastTps</a>
    </li>
    <li>
      <a href="../articles/predictSurface.html">predictSurface</a>
    </li>
  </ul></li>
      </ul><ul class="nav navbar-nav navbar-right"><li>
  <a href="https://github.com/dnychka/fieldsRPackage/" class="external-link">
    <span class="fab fa-github fa-lg"></span>
     
  </a>
</li>
      </ul></div><!--/.nav-collapse -->
  </div><!--/.container -->
</div><!--/.navbar -->

      

      </header><div class="row">
  <div class="col-md-9 contents">
    <div class="page-header">
    <h1>Thin plate spline regression</h1>
    
    <div class="hidden name"><code>Tps.Rd</code></div>
    </div>

    <div class="ref-description">
    <p>Fits a thin plate spline surface to irregularly spaced data. The 
smoothing parameter is chosen by generalized cross-validation. The assumed 
model is additive  Y = f(X) +e  where f(X) is a d dimensional surface.
This is the classic nonparametric curve/surface estimate pioneered in statistics by Grace Wahba.
This function also works for just a single dimension and is a special case of a Gaussian process estimate as the range parameter in the Matern family increases to infinity. 
(Kriging).</p>
<p>A "fast" version of this function uses a compactly supported Wendland covariance and sparse linear algebra for handling larger datta sets. Although a good approximation to Tps for sufficiently large aRange its actual form is very different from the textbook thin-plate definition.</p>
    </div>

    <div id="ref-usage">
    <div class="sourceCode"><pre class="sourceCode r"><code><span><span class="fu">Tps</span><span class="op">(</span><span class="va">x</span>, <span class="va">Y</span>, m <span class="op">=</span> <span class="cn">NULL</span>, p <span class="op">=</span> <span class="cn">NULL</span>, scale.type <span class="op">=</span> <span class="st">"range"</span>, lon.lat <span class="op">=</span> <span class="cn">FALSE</span>,</span>
<span>         miles <span class="op">=</span> <span class="cn">TRUE</span>, method <span class="op">=</span> <span class="st">"GCV"</span>, GCV <span class="op">=</span> <span class="cn">TRUE</span>, <span class="va">...</span><span class="op">)</span></span>
<span></span>
<span><span class="fu">fastTps</span><span class="op">(</span><span class="va">x</span>, <span class="va">Y</span>, m <span class="op">=</span> <span class="cn">NULL</span>, p <span class="op">=</span> <span class="cn">NULL</span>, <span class="va">aRange</span>, lon.lat <span class="op">=</span> <span class="cn">FALSE</span>,</span>
<span>                 find.trA <span class="op">=</span> <span class="cn">FALSE</span>, REML <span class="op">=</span> <span class="cn">FALSE</span>,theta<span class="op">=</span><span class="cn">NULL</span>,  <span class="va">...</span><span class="op">)</span></span></code></pre></div>
    </div>

    <div id="arguments">
    <h2>Arguments</h2>
    

<p><!-- %To be helpful, a more complete list of arguments are described that are the  --></p>


<p><!-- %same as those for the Krig function.   --></p>
<dl><dt>x</dt>
<dd><p>Matrix of independent variables. Each row is a location or a set of 
independent covariates.</p></dd>

<dt>Y</dt>
<dd><p>Vector of dependent variables.</p></dd>

<dt>m</dt>
<dd><p>A polynomial function of degree (m-1) will be  
included in the model as the drift (or spatial trend) component. 
Default is the value such that 2m-d is greater than zero where d is the 
dimension of x.</p></dd>


<dt>p</dt>
<dd><p>Polynomial power for Wendland radial basis functions. Default is 2m-d 
where d is the dimension of x.</p></dd>


<dt>scale.type</dt>
<dd><p>The independent variables and knots are scaled to the specified 
scale.type. 
By default the scale type is "range", whereby 
the locations are transformed  
 to the interval (0,1) by forming (x-min(x))/range(x) for each x. 
Scale type of "user" allows specification of an x.center and
x.scale by the 
user. The default for "user" is mean 0 and standard deviation 1. Scale 
type of "unscaled" does not scale the data.</p></dd>

<dt>aRange</dt>
<dd><p>The tapering range that is passed to the Wendland compactly 
supported covariance. The covariance (i.e. the radial basis function) is 
zero beyond range aRange. The larger aRange the closer this model will
approximate the standard thin plate spline.</p></dd>


<dt>lon.lat</dt>
<dd><p>If TRUE locations are interpreted as lognitude and
latitude and great circle distance is used to find distances among
locations. The aRange scale parameter for <code>fast.Tps</code> (setting the
compact support of the Wendland function) in this case is in units of
miles (see example and caution below).</p></dd>

 
 <dt>method</dt>
<dd><p>Determines what "smoothing" parameter should be
     used. The default is to estimate standard GCV Other choices are:
     GCV.model, GCV.one, RMSE, pure error and REML. The differences
     are explained in the Krig help file.</p></dd>

     
 <dt>GCV</dt>
<dd><p>If TRUE the decompositions are done to efficiently evaluate
 the estimate, GCV function and likelihood at multiple values
 of lambda.</p></dd>
    
 
<dt>miles</dt>
<dd><p>If TRUE great circle distances are in miles if FALSE
distances are in kilometers</p></dd>



<dt>find.trA</dt>
<dd><p>If TRUE will estimate the effective degrees of freedom
using a simple Monte Carlo method (random trace). This will add to the
computational burden by approximately <code>NtrA</code> solutions of the
linear system but
the cholesky decomposition is reused.</p></dd>


<dt>REML</dt>
<dd><p>If TRUE find the MLE for lambda using restricted maximum likelihood instead of the full version.</p></dd>


<dt>theta</dt>
<dd><p>Same as aRange.</p></dd>

  
<dt>...</dt>
<dd><p>For <code>Tps</code> any argument that is valid for the
<code>Krig</code> function. Some of the main ones are listed below.</p>
<p>For <code>fastTps</code> any argument that is suitable for the <code>mKrig</code>
function see help on mKrig for these choices. The most common would be
<code>lambda</code> fixing the value of this parameter (tau^2/sigma^2), <code>Z</code> linear covariates or 
<code> mKrig.args= list( m=1)</code> setting the regression model to be just a constant function.</p>
<p>Arguments for Tps:</p><dl><dt>lambda</dt>
<dd><p>Smoothing parameter that is the ratio of the error
    variance (tau**2) to the scale parameter of the covariance
    function. If omitted this is estimated by GCV.</p></dd>


  <dt>Z</dt>
<dd><p>Linear covariates to be included in fixed part of the model
    that are distinct from the default low order polynomial in
    <code>x</code></p></dd>


  <dt>df</dt>
<dd><p>The effective number of parameters for the fitted
    surface. Conversely, N- df, where N is the total number of
    observations is the degrees of freedom associated with the
    residuals.  This is an alternative to specifying lambda and much
    more interpretable.</p></dd>


  <dt>cost</dt>
<dd><p>Cost value used in GCV criterion. Corresponds to a
    penalty for increased number of parameters. The default is 1.0 and
    corresponds to the usual GCV.</p></dd>


  <dt>weights</dt>
<dd><p>Weights are proportional to the reciprocal variance
    of the measurement error. The default is no weighting i.e. vector
    of unit weights.</p></dd>


  <dt>nstep.cv</dt>
<dd><p>Number of grid points for minimum GCV search.</p></dd>


  <dt>x.center</dt>
<dd><p>Centering values are subtracted from each column of
     the x matrix.  Must have scale.type="user".</p></dd>


  <dt>x.scale</dt>
<dd><p>Scale values that divided into each column after
    centering.  Must have scale.type="user".</p></dd>


  <dt>sigma</dt>
<dd><p>Scale factor for covariance.</p></dd>


  <dt>tau2</dt>
<dd><p>Variance of errors or if weights are not equal to 1
     the variance is tau**2/weight.</p></dd>


 

   <dt>verbose</dt>
<dd><p>If true will print out all kinds of intermediate
      stuff.</p></dd>


   <dt>mean.obj</dt>
<dd><p>Object to predict the mean of the spatial
      process.</p></dd>


   <dt>sd.obj</dt>
<dd><p>Object to predict the marginal standard deviation of
      the spatial process.</p></dd>


    <dt>null.function</dt>
<dd><p>An R function that creates the matrices for
       the null space model.  The default is fields.mkpoly, an R
       function that creates a polynomial regression matrix with all
       terms up to degree m-1. (See Details)</p></dd>


     <dt>offset</dt>
<dd><p>The offset to be used in the GCV
        criterion. Default is 0. This would be used when Krig/Tps is
        part of a backfitting algorithm and the offset has to be
        included to reflect other model degrees of freedom.</p></dd>


</dl></dd>



</dl></div>
    <div id="value">
    <h2>Value</h2>
    

<p>A list of class Krig. This includes the 
fitted values, the predicted surface evaluated at the 
observation locations, and the residuals. The results of the grid 
search minimizing the generalized cross validation function are
returned in gcv.grid. Note that the GCV/REML optimization is 
done even if lambda or df is given. 
Please see the documentation on Krig for details of the returned 
arguments.</p>
    </div>
    <div id="details">
    <h2>Details</h2>
    <p>Both of these functions are special cases of using the 
<code>Krig</code> and <code>mKrig</code> functions. See the help on each of these
for more information on the calling arguments and what is returned. 
<code>Tps</code> makes use of the stable computations via eigen decompositions in <code>Krig</code>. <code>fastTps</code> follows the more standard computations for spatial statistics centered around the Cholesky decomposition in <code>mKrig</code>.</p>
<p>A thin plate spline is the result of minimizing the residual sum of 
squares subject to a constraint that the function have a certain 
level of smoothness (or roughness penalty). Roughness is 
quantified by the integral of squared m-th order derivatives. For one 
dimension and m=2 the roughness penalty is the integrated square of 
the second derivative of the function. For two dimensions the 
roughness penalty is the integral of</p>
<p>(Dxx(f))**22 + 2(Dxy(f))**2 + (Dyy(f))**22</p>
<p>(where Duv denotes the second partial derivative with respect to u 
and v.) Besides controlling the order of the derivatives, the value of 
m also determines the base polynomial that is fit to the data. 
The degree of this polynomial is (m-1).</p>
<p>The smoothing parameter controls the amount that the data is 
smoothed. In the usual form this is denoted by lambda, the Lagrange 
multiplier of the minimization problem. Although this is an awkward 
scale, lambda = 0 corresponds to no smoothness constraints and the data 
is interpolated.  lambda=infinity corresponds to just fitting the 
polynomial base model by ordinary least squares.</p>
<p>This estimator is implemented by passing the right generalized covariance
function based on radial basis functions to the more general function
Krig.  One advantage of this implementation is that once a Tps/Krig object
is created the estimator can be found rapidly for other data and smoothing
parameters provided the locations remain unchanged. This makes simulation
within R efficient (see example below). Tps does not currently support the
knots argument where one can use a reduced set of basis functions. This is
mainly to simplify the code and a good alternative using knots would be to use a
valid covariance from the Matern family and a large range parameter.</p>
<p>CAUTION about <code>lon.lat=TRUE</code>: The option to use great circle distance
 to define the radial basis functions (<code>lon.lat=TRUE</code>) is very useful
 for small geographic domains where the spherical geometry is well approximated by a plane. However, for large domains the spherical distortion be large enough that the basis function no longer define a positive definite system and Tps will report a numerical error. An alternative is to switch to a three
dimensional thin plate spline the locations being the direction cosines. This will 
give approximate great circle distances for locations that are close and also the numerical methods will always have a positive definite matrices.</p>
<p>Here is an example using this idea for <code>RMprecip</code> and also some 
examples of building grids and evaluating the Tps results on them:</p><div class="sourceCode"><pre><code><span></span>
<span><span class="co"># a useful function:</span></span>
<span>  <span class="va">dircos</span><span class="op">&lt;-</span> <span class="kw">function</span><span class="op">(</span><span class="va">x1</span><span class="op">)</span><span class="op">{</span></span>
<span>             <span class="va">coslat1</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/Trig.html" class="external-link">cos</a></span><span class="op">(</span><span class="op">(</span><span class="va">x1</span><span class="op">[</span>, <span class="fl">2</span><span class="op">]</span> <span class="op">*</span> <span class="va">pi</span><span class="op">)</span><span class="op">/</span><span class="fl">180</span><span class="op">)</span></span>
<span>             <span class="va">sinlat1</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/Trig.html" class="external-link">sin</a></span><span class="op">(</span><span class="op">(</span><span class="va">x1</span><span class="op">[</span>, <span class="fl">2</span><span class="op">]</span> <span class="op">*</span> <span class="va">pi</span><span class="op">)</span><span class="op">/</span><span class="fl">180</span><span class="op">)</span></span>
<span>             <span class="va">coslon1</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/Trig.html" class="external-link">cos</a></span><span class="op">(</span><span class="op">(</span><span class="va">x1</span><span class="op">[</span>, <span class="fl">1</span><span class="op">]</span> <span class="op">*</span> <span class="va">pi</span><span class="op">)</span><span class="op">/</span><span class="fl">180</span><span class="op">)</span></span>
<span>             <span class="va">sinlon1</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/Trig.html" class="external-link">sin</a></span><span class="op">(</span><span class="op">(</span><span class="va">x1</span><span class="op">[</span>, <span class="fl">1</span><span class="op">]</span> <span class="op">*</span> <span class="va">pi</span><span class="op">)</span><span class="op">/</span><span class="fl">180</span><span class="op">)</span></span>
<span>             <span class="fu"><a href="https://rdrr.io/r/base/cbind.html" class="external-link">cbind</a></span><span class="op">(</span><span class="va">coslon1</span><span class="op">*</span><span class="va">coslat1</span>, <span class="va">sinlon1</span><span class="op">*</span><span class="va">coslat1</span>, <span class="va">sinlat1</span><span class="op">)</span><span class="op">}</span></span>
<span><span class="co"># fit in 3-d to direction cosines</span></span>
<span>  <span class="va">out</span><span class="op">&lt;-</span> <span class="fu"><a href="../reference/Tps.html">Tps</a></span><span class="op">(</span><span class="fu">dircos</span><span class="op">(</span><span class="va">RMprecip</span><span class="op">$</span><span class="va">x</span><span class="op">)</span>,<span class="va">RMprecip</span><span class="op">$</span><span class="va">y</span><span class="op">)</span></span>
<span>  <span class="va">xg</span><span class="op">&lt;-</span><span class="fu"><a href="../reference/grid.list.html">make.surface.grid</a></span><span class="op">(</span><span class="fu"><a href="../reference/grid.list.html">fields.x.to.grid</a></span><span class="op">(</span><span class="va">RMprecip</span><span class="op">$</span><span class="va">x</span><span class="op">)</span><span class="op">)</span></span>
<span>  <span class="va">fhat</span><span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/stats/predict.html" class="external-link">predict</a></span><span class="op">(</span> <span class="va">out</span>, <span class="fu">dircos</span><span class="op">(</span><span class="va">xg</span><span class="op">)</span><span class="op">)</span></span>
<span><span class="co"># coerce to image format from prediction vector and grid points.</span></span>
<span>  <span class="va">out.p</span><span class="op">&lt;-</span> <span class="fu"><a href="../reference/as.surface.html">as.surface</a></span><span class="op">(</span> <span class="va">xg</span>, <span class="va">fhat</span><span class="op">)</span></span>
<span>  <span class="fu"><a href="../reference/fields-internal.html">surface</a></span><span class="op">(</span> <span class="va">out.p</span><span class="op">)</span></span>
<span><span class="co"># compare to the automatic</span></span>
<span>  <span class="va">out0</span><span class="op">&lt;-</span> <span class="fu"><a href="../reference/Tps.html">Tps</a></span><span class="op">(</span><span class="va">RMprecip</span><span class="op">$</span><span class="va">x</span>,<span class="va">RMprecip</span><span class="op">$</span><span class="va">y</span>, lon.lat<span class="op">=</span><span class="cn">TRUE</span><span class="op">)</span></span>
<span>  <span class="fu"><a href="../reference/fields-internal.html">surface</a></span><span class="op">(</span><span class="va">out0</span><span class="op">)</span></span></code></pre></div>

<p>The function <code>fastTps</code> is really a convenient wrapper function that
calls <code>spatialProcess</code> with a suitable Wendland covariance 
function. This means one can use all the additional functions for
prediction and simulation built for the <code>spatialProcess</code> and
<code>mKrig</code> objects.</p>
<p>This is function is 
experimental, however, and some care needs to exercised in specifying
the support <code>aRange</code> 
 and power ( <code>p</code>) which describes the polynomial behavior of 
the Wendland at the origin. Note that unlike Tps the locations are not 
scaled to unit range and this can cause havoc in smoothing problems with
variables in very different units. 
So rescaling the locations <code> x&lt;- scale(x)</code> 
is a good idea for putting the variables on a common scale
for smoothing.  A conservative rule of thumb is to make <code>aRange</code>
large enough so that about 50 nearest neighbors are within this distance
for every observation location.</p>
<p>This function does have the potential to approximate estimates of Tps 
for very large spatial data sets. See <code>wendland.cov</code> and help on 
the SPAM package for more background.
Also, the function <code>predictSurface.fastTps</code> has been made more
efficient for the 
case of k=2 and m=2.</p>
<p>See also the mKrig function for handling larger data sets and also for
an example
of combining Tps and mKrig for evaluation on a huge grid.</p>
<p></p>
    </div>
    <div id="references">
    <h2>References</h2>
    <p>See "Nonparametric Regression and Generalized Linear Models"  
by Green and Silverman. 
See "Additive Models" by Hastie and Tibshirani.</p>
    </div>
    <div id="see-also">
    <h2>See also</h2>
    <div class="dont-index"><p><code><a href="Krig.html">Krig</a></code>,
<code><a href="mKrig.html">mKrig</a></code>,
<code><a href="spatialProcess.html">spatialProcess</a></code>,
<code><a href="sim.Krig.html">sim.spatialProcess</a></code>,
<code><a href="summary.Krig.html">summary.Krig</a></code>,
<code><a href="predict.Krig.html">predict.Krig</a></code>,
<code><a href="predictSE.Krig.html">predictSE.Krig</a></code>,
<code><a href="predictSurface.html">predictSurface</a></code>,
<code><a href="predictSurface.html">predictSurface.fastTps</a></code>,
<code><a href="plot.Krig.html">plot.Krig</a></code>,
<code><a href="surface.Krig.html">surface.Krig</a></code>, 
<code><a href="sreg.html">sreg</a></code></p></div>
    </div>

    <div id="ref-examples">
    <h2>Examples</h2>
    <div class="sourceCode"><pre class="sourceCode r"><code><span class="r-in"><span><span class="co">#2-d example </span></span></span>
<span class="r-in"><span></span></span>
<span class="r-in"><span><span class="va">fit</span><span class="op">&lt;-</span> <span class="fu">Tps</span><span class="op">(</span><span class="va">ChicagoO3</span><span class="op">$</span><span class="va">x</span>, <span class="va">ChicagoO3</span><span class="op">$</span><span class="va">y</span><span class="op">)</span>  <span class="co"># fits a surface to ozone measurements. </span></span></span>
<span class="r-in"><span></span></span>
<span class="r-in"><span><span class="fu"><a href="set.panel.html">set.panel</a></span><span class="op">(</span><span class="fl">2</span>,<span class="fl">2</span><span class="op">)</span></span></span>
<span class="r-out co"><span class="r-pr">#&gt;</span> plot window will lay out plots in a 2 by 2 matrix </span>
<span class="r-in"><span><span class="fu"><a href="https://rdrr.io/r/graphics/plot.default.html" class="external-link">plot</a></span><span class="op">(</span><span class="va">fit</span><span class="op">)</span> <span class="co"># four diagnostic plots of  fit and residuals. </span></span></span>
<span class="r-plt img"><img src="Tps-1.png" alt="" width="700" height="433"></span>
<span class="r-in"><span><span class="fu"><a href="set.panel.html">set.panel</a></span><span class="op">(</span><span class="op">)</span></span></span>
<span class="r-out co"><span class="r-pr">#&gt;</span> plot window will lay out plots in a 1 by 1 matrix </span>
<span class="r-in"><span></span></span>
<span class="r-in"><span><span class="co"># summary of fit and estiamtes of lambda the smoothing parameter</span></span></span>
<span class="r-in"><span><span class="fu"><a href="https://rdrr.io/r/base/summary.html" class="external-link">summary</a></span><span class="op">(</span><span class="va">fit</span><span class="op">)</span></span></span>
<span class="r-out co"><span class="r-pr">#&gt;</span> CALL:</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> Tps(x = ChicagoO3$x, Y = ChicagoO3$y)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>                                                </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>  Number of Observations:                20     </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>  Number of unique points:               20     </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>  Number of parameters in the null space 3      </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>  Parameters for fixed spatial drift     3      </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>  Effective degrees of freedom:          4.5    </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>  Residual degrees of freedom:           15.5   </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>  MLE tau                                3.779  </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>  GCV tau                                4.073  </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>  MLE sigma                              347.7  </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>  Scale passed for covariance (sigma)    &lt;NA&gt;   </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>  Scale passed for nugget (tau^2)        &lt;NA&gt;   </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>  Smoothing parameter lambda             0.04107</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> Residual Summary:</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     min   1st Q  median   3rd Q     max </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> -6.8060 -1.4390 -0.5064  1.4440  7.7890 </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> Covariance Model: Rad.cov</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   Names of non-default covariance arguments: </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>        p</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> DETAILS ON SMOOTHING PARAMETER:</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>  Method used:   GCV    Cost:  1</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>    lambda       trA       GCV   GCV.one GCV.model    tauHat </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   0.04107   4.50304  21.40938  21.40938        NA   4.07296 </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>  Summary of all estimates found for lambda</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             lambda   trA   GCV tauHat -lnLike Prof converge</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> GCV        0.04107 4.503 21.41  4.073        49.00        5</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> GCV.model       NA    NA    NA     NA           NA       NA</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> GCV.one    0.04107 4.503 21.41  4.073           NA        5</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> RMSE            NA    NA    NA     NA           NA       NA</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> pure error      NA    NA    NA     NA           NA       NA</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> REML       0.02972 4.886 21.49  4.030        48.98        4</span>
<span class="r-in"><span></span></span>
<span class="r-in"><span><span class="fu"><a href="fields-internal.html">surface</a></span><span class="op">(</span> <span class="va">fit</span><span class="op">)</span> <span class="co"># Quick image/contour plot of GCV surface.</span></span></span>
<span class="r-plt img"><img src="Tps-2.png" alt="" width="700" height="433"></span>
<span class="r-in"><span></span></span>
<span class="r-in"><span><span class="co"># NOTE: the predict function is quite flexible:</span></span></span>
<span class="r-in"><span></span></span>
<span class="r-in"><span>     <span class="va">look</span><span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/stats/predict.html" class="external-link">predict</a></span><span class="op">(</span> <span class="va">fit</span>, lambda<span class="op">=</span><span class="fl">2.0</span><span class="op">)</span></span></span>
<span class="r-in"><span><span class="co">#  evaluates the estimate at lambda =2.0  _not_ the GCV estimate</span></span></span>
<span class="r-in"><span><span class="co">#  it does so very efficiently from the Krig fit object.</span></span></span>
<span class="r-in"><span></span></span>
<span class="r-in"><span>     <span class="va">look</span><span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/stats/predict.html" class="external-link">predict</a></span><span class="op">(</span> <span class="va">fit</span>, df<span class="op">=</span><span class="fl">7.5</span><span class="op">)</span></span></span>
<span class="r-in"><span><span class="co">#  evaluates the estimate at the lambda values such that </span></span></span>
<span class="r-in"><span><span class="co">#  the effective degrees of freedom is 7.5</span></span></span>
<span class="r-in"><span> </span></span>
<span class="r-in"><span></span></span>
<span class="r-in"><span><span class="co"># compare this to fitting a thin plate spline with </span></span></span>
<span class="r-in"><span><span class="co"># lambda chosen so that there are 7.5 effective </span></span></span>
<span class="r-in"><span><span class="co"># degrees of freedom in estimate</span></span></span>
<span class="r-in"><span><span class="co"># Note that the GCV function is still computed and minimized</span></span></span>
<span class="r-in"><span><span class="co"># but the lambda values used correpsonds to 7.5 df.</span></span></span>
<span class="r-in"><span></span></span>
<span class="r-in"><span><span class="va">fit1</span><span class="op">&lt;-</span> <span class="fu">Tps</span><span class="op">(</span><span class="va">ChicagoO3</span><span class="op">$</span><span class="va">x</span>, <span class="va">ChicagoO3</span><span class="op">$</span><span class="va">y</span>,df<span class="op">=</span><span class="fl">7.5</span><span class="op">)</span></span></span>
<span class="r-in"><span></span></span>
<span class="r-in"><span><span class="fu"><a href="set.panel.html">set.panel</a></span><span class="op">(</span><span class="fl">2</span>,<span class="fl">2</span><span class="op">)</span></span></span>
<span class="r-out co"><span class="r-pr">#&gt;</span> plot window will lay out plots in a 2 by 2 matrix </span>
<span class="r-in"><span><span class="fu"><a href="https://rdrr.io/r/graphics/plot.default.html" class="external-link">plot</a></span><span class="op">(</span><span class="va">fit1</span><span class="op">)</span> <span class="co"># four diagnostic plots of  fit and residuals.</span></span></span>
<span class="r-plt img"><img src="Tps-3.png" alt="" width="700" height="433"></span>
<span class="r-in"><span>          <span class="co"># GCV function (lower left) has vertical line at 7.5 df.</span></span></span>
<span class="r-in"><span><span class="fu"><a href="set.panel.html">set.panel</a></span><span class="op">(</span><span class="op">)</span></span></span>
<span class="r-out co"><span class="r-pr">#&gt;</span> plot window will lay out plots in a 1 by 1 matrix </span>
<span class="r-in"><span></span></span>
<span class="r-in"><span><span class="co"># The basic matrix decompositions are the same for </span></span></span>
<span class="r-in"><span><span class="co"># both fit and fit1 objects. </span></span></span>
<span class="r-in"><span></span></span>
<span class="r-in"><span><span class="co"># predict( fit1) is the same as predict( fit, df=7.5)</span></span></span>
<span class="r-in"><span><span class="co"># predict( fit1, lambda= fit$lambda) is the same as predict(fit) </span></span></span>
<span class="r-in"><span></span></span>
<span class="r-in"><span></span></span>
<span class="r-in"><span><span class="co"># predict onto a grid that matches the ranges of the data.  </span></span></span>
<span class="r-in"><span></span></span>
<span class="r-in"><span><span class="va">out.p</span><span class="op">&lt;-</span><span class="fu"><a href="predictSurface.html">predictSurface</a></span><span class="op">(</span> <span class="va">fit</span><span class="op">)</span></span></span>
<span class="r-in"><span><span class="fu"><a href="https://rdrr.io/r/graphics/image.html" class="external-link">image</a></span><span class="op">(</span> <span class="va">out.p</span><span class="op">)</span> </span></span>
<span class="r-plt img"><img src="Tps-4.png" alt="" width="700" height="433"></span>
<span class="r-in"><span></span></span>
<span class="r-in"><span><span class="co"># the surface function (e.g. surface( fit))  essentially combines </span></span></span>
<span class="r-in"><span><span class="co"># the two steps above</span></span></span>
<span class="r-in"><span></span></span>
<span class="r-in"><span><span class="co"># predict at different effective </span></span></span>
<span class="r-in"><span><span class="co"># number of parameters </span></span></span>
<span class="r-in"><span><span class="va">out.p</span><span class="op">&lt;-</span><span class="fu"><a href="predictSurface.html">predictSurface</a></span><span class="op">(</span> <span class="va">fit</span>,df<span class="op">=</span><span class="fl">10</span><span class="op">)</span></span></span>
<span class="r-in"><span></span></span>
<span class="r-in"><span><span class="kw">if</span> <span class="op">(</span><span class="cn">FALSE</span><span class="op">)</span> <span class="op">{</span></span></span>
<span class="r-in"><span><span class="co"># predicting on a grid along with a covariate</span></span></span>
<span class="r-in"><span>  <span class="fu"><a href="https://rdrr.io/r/utils/data.html" class="external-link">data</a></span><span class="op">(</span> <span class="va">COmonthlyMet</span><span class="op">)</span>  </span></span>
<span class="r-in"><span><span class="co"># predicting average daily minimum temps for spring in Colorado</span></span></span>
<span class="r-in"><span><span class="co"># NOTE to create an  4km  elevation grid: </span></span></span>
<span class="r-in"><span><span class="co"># data(PRISMelevation); CO.elev1 &lt;- crop.image(PRISMelevation, CO.loc )</span></span></span>
<span class="r-in"><span><span class="co"># then use same grid for the predictions: CO.Grid1&lt;- CO.elev1[c("x","y")]</span></span></span>
<span class="r-in"><span>  <span class="va">obj</span><span class="op">&lt;-</span> <span class="fu">Tps</span><span class="op">(</span> <span class="va">CO.loc</span>, <span class="va">CO.tmin.MAM.climate</span>, Z<span class="op">=</span> <span class="va">CO.elev</span><span class="op">)</span></span></span>
<span class="r-in"><span>  <span class="va">out.p</span><span class="op">&lt;-</span><span class="fu"><a href="predictSurface.html">predictSurface</a></span><span class="op">(</span> <span class="va">obj</span>,</span></span>
<span class="r-in"><span>              <span class="va">CO.Grid</span>, ZGrid<span class="op">=</span> <span class="va">CO.elevGrid</span><span class="op">)</span></span></span>
<span class="r-in"><span>  <span class="fu"><a href="imagePlot.html">imagePlot</a></span><span class="op">(</span> <span class="va">out.p</span><span class="op">)</span>        </span></span>
<span class="r-in"><span>  <span class="fu"><a href="US.html">US</a></span><span class="op">(</span>add<span class="op">=</span><span class="cn">TRUE</span>, col<span class="op">=</span><span class="st">"grey"</span><span class="op">)</span></span></span>
<span class="r-in"><span>  <span class="fu"><a href="https://rdrr.io/r/graphics/contour.html" class="external-link">contour</a></span><span class="op">(</span> <span class="va">CO.elevGrid</span>, add<span class="op">=</span><span class="cn">TRUE</span>, levels<span class="op">=</span><span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="fl">2000</span><span class="op">)</span>, col<span class="op">=</span><span class="st">"black"</span><span class="op">)</span></span></span>
<span class="r-in"><span><span class="op">}</span></span></span>
<span class="r-in"><span><span class="kw">if</span> <span class="op">(</span><span class="cn">FALSE</span><span class="op">)</span> <span class="op">{</span></span></span>
<span class="r-in"><span><span class="co">#A 1-d example  with confidence intervals</span></span></span>
<span class="r-in"><span>  <span class="va">out</span><span class="op">&lt;-</span><span class="fu">Tps</span><span class="op">(</span> <span class="va">rat.diet</span><span class="op">$</span><span class="va">t</span>, <span class="va">rat.diet</span><span class="op">$</span><span class="va">trt</span><span class="op">)</span> <span class="co"># lambda found by GCV </span></span></span>
<span class="r-in"><span>  <span class="va">out</span></span></span>
<span class="r-in"><span>  <span class="fu"><a href="https://rdrr.io/r/graphics/plot.default.html" class="external-link">plot</a></span><span class="op">(</span> <span class="va">out</span><span class="op">$</span><span class="va">x</span>, <span class="va">out</span><span class="op">$</span><span class="va">y</span><span class="op">)</span></span></span>
<span class="r-in"><span>  <span class="va">xgrid</span><span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/seq.html" class="external-link">seq</a></span><span class="op">(</span>  <span class="fu"><a href="https://rdrr.io/r/base/Extremes.html" class="external-link">min</a></span><span class="op">(</span> <span class="va">out</span><span class="op">$</span><span class="va">x</span><span class="op">)</span>, <span class="fu"><a href="https://rdrr.io/r/base/Extremes.html" class="external-link">max</a></span><span class="op">(</span> <span class="va">out</span><span class="op">$</span><span class="va">x</span><span class="op">)</span>,,<span class="fl">100</span><span class="op">)</span></span></span>
<span class="r-in"><span>  <span class="va">fhat</span><span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/stats/predict.html" class="external-link">predict</a></span><span class="op">(</span> <span class="va">out</span>,<span class="va">xgrid</span><span class="op">)</span></span></span>
<span class="r-in"><span>  <span class="fu"><a href="https://rdrr.io/r/graphics/lines.html" class="external-link">lines</a></span><span class="op">(</span> <span class="va">xgrid</span>, <span class="va">fhat</span>,<span class="op">)</span></span></span>
<span class="r-in"><span>  <span class="va">SE</span><span class="op">&lt;-</span> <span class="fu"><a href="predictSE.Krig.html">predictSE</a></span><span class="op">(</span> <span class="va">out</span>, <span class="va">xgrid</span><span class="op">)</span></span></span>
<span class="r-in"><span>  <span class="fu"><a href="https://rdrr.io/r/graphics/lines.html" class="external-link">lines</a></span><span class="op">(</span> <span class="va">xgrid</span>,<span class="va">fhat</span> <span class="op">+</span> <span class="fl">1.96</span><span class="op">*</span> <span class="va">SE</span>, col<span class="op">=</span><span class="st">"red"</span>, lty<span class="op">=</span><span class="fl">2</span><span class="op">)</span></span></span>
<span class="r-in"><span>  <span class="fu"><a href="https://rdrr.io/r/graphics/lines.html" class="external-link">lines</a></span><span class="op">(</span><span class="va">xgrid</span>, <span class="va">fhat</span> <span class="op">-</span> <span class="fl">1.96</span><span class="op">*</span><span class="va">SE</span>, col<span class="op">=</span><span class="st">"red"</span>, lty<span class="op">=</span><span class="fl">2</span><span class="op">)</span></span></span>
<span class="r-in"><span></span></span>
<span class="r-in"><span><span class="co"># </span></span></span>
<span class="r-in"><span><span class="co"># compare to the ( much faster) B spline algorithm </span></span></span>
<span class="r-in"><span><span class="co">#  sreg(rat.diet$t, rat.diet$trt) </span></span></span>
<span class="r-in"><span></span></span>
<span class="r-in"><span><span class="co"># Here is a 1-d example with 95 percent  CIs  where sreg would not </span></span></span>
<span class="r-in"><span><span class="co"># work:</span></span></span>
<span class="r-in"><span><span class="co">#  sreg would give the right estimate here but not the right CI's</span></span></span>
<span class="r-in"><span>  <span class="va">x</span><span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/seq.html" class="external-link">seq</a></span><span class="op">(</span> <span class="fl">0</span>,<span class="fl">1</span>,,<span class="fl">8</span><span class="op">)</span></span></span>
<span class="r-in"><span>  <span class="va">y</span><span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/Trig.html" class="external-link">sin</a></span><span class="op">(</span><span class="fl">3</span><span class="op">*</span><span class="va">x</span><span class="op">)</span></span></span>
<span class="r-in"><span>  <span class="va">out</span><span class="op">&lt;-</span><span class="fu">Tps</span><span class="op">(</span> <span class="va">x</span>, <span class="va">y</span><span class="op">)</span> <span class="co"># lambda found by GCV </span></span></span>
<span class="r-in"><span>  <span class="fu"><a href="https://rdrr.io/r/graphics/plot.default.html" class="external-link">plot</a></span><span class="op">(</span> <span class="va">out</span><span class="op">$</span><span class="va">x</span>, <span class="va">out</span><span class="op">$</span><span class="va">y</span><span class="op">)</span></span></span>
<span class="r-in"><span>  <span class="va">xgrid</span><span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/seq.html" class="external-link">seq</a></span><span class="op">(</span>  <span class="fu"><a href="https://rdrr.io/r/base/Extremes.html" class="external-link">min</a></span><span class="op">(</span> <span class="va">out</span><span class="op">$</span><span class="va">x</span><span class="op">)</span>, <span class="fu"><a href="https://rdrr.io/r/base/Extremes.html" class="external-link">max</a></span><span class="op">(</span> <span class="va">out</span><span class="op">$</span><span class="va">x</span><span class="op">)</span>,,<span class="fl">100</span><span class="op">)</span></span></span>
<span class="r-in"><span>  <span class="va">fhat</span><span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/stats/predict.html" class="external-link">predict</a></span><span class="op">(</span> <span class="va">out</span>,<span class="va">xgrid</span><span class="op">)</span></span></span>
<span class="r-in"><span>  <span class="fu"><a href="https://rdrr.io/r/graphics/lines.html" class="external-link">lines</a></span><span class="op">(</span> <span class="va">xgrid</span>, <span class="va">fhat</span>, lwd<span class="op">=</span><span class="fl">2</span><span class="op">)</span></span></span>
<span class="r-in"><span>  <span class="va">SE</span><span class="op">&lt;-</span> <span class="fu"><a href="predictSE.Krig.html">predictSE</a></span><span class="op">(</span> <span class="va">out</span>, <span class="va">xgrid</span><span class="op">)</span></span></span>
<span class="r-in"><span>  <span class="fu"><a href="https://rdrr.io/r/graphics/lines.html" class="external-link">lines</a></span><span class="op">(</span> <span class="va">xgrid</span>,<span class="va">fhat</span> <span class="op">+</span> <span class="fl">1.96</span><span class="op">*</span> <span class="va">SE</span>, col<span class="op">=</span><span class="st">"red"</span>, lty<span class="op">=</span><span class="fl">2</span><span class="op">)</span></span></span>
<span class="r-in"><span>  <span class="fu"><a href="https://rdrr.io/r/graphics/lines.html" class="external-link">lines</a></span><span class="op">(</span><span class="va">xgrid</span>, <span class="va">fhat</span> <span class="op">-</span> <span class="fl">1.96</span><span class="op">*</span><span class="va">SE</span>, col<span class="op">=</span><span class="st">"red"</span>, lty<span class="op">=</span><span class="fl">2</span><span class="op">)</span></span></span>
<span class="r-in"><span><span class="op">}</span></span></span>
<span class="r-in"><span></span></span>
<span class="r-in"><span><span class="co"># More involved example adding a covariate to the fixed part of model</span></span></span>
<span class="r-in"><span><span class="kw">if</span> <span class="op">(</span><span class="cn">FALSE</span><span class="op">)</span> <span class="op">{</span></span></span>
<span class="r-in"><span><span class="fu"><a href="set.panel.html">set.panel</a></span><span class="op">(</span> <span class="fl">1</span>,<span class="fl">3</span><span class="op">)</span></span></span>
<span class="r-in"><span><span class="co"># without elevation covariate</span></span></span>
<span class="r-in"><span>  <span class="va">out0</span><span class="op">&lt;-</span><span class="fu">Tps</span><span class="op">(</span> <span class="va">RMprecip</span><span class="op">$</span><span class="va">x</span>,<span class="va">RMprecip</span><span class="op">$</span><span class="va">y</span><span class="op">)</span></span></span>
<span class="r-in"><span>  <span class="fu"><a href="fields-internal.html">surface</a></span><span class="op">(</span> <span class="va">out0</span><span class="op">)</span></span></span>
<span class="r-in"><span>  <span class="fu"><a href="US.html">US</a></span><span class="op">(</span> add<span class="op">=</span><span class="cn">TRUE</span>, col<span class="op">=</span><span class="st">"grey"</span><span class="op">)</span></span></span>
<span class="r-in"><span></span></span>
<span class="r-in"><span><span class="co"># with elevation covariate</span></span></span>
<span class="r-in"><span>  <span class="va">out</span><span class="op">&lt;-</span> <span class="fu">Tps</span><span class="op">(</span> <span class="va">RMprecip</span><span class="op">$</span><span class="va">x</span>,<span class="va">RMprecip</span><span class="op">$</span><span class="va">y</span>, Z<span class="op">=</span><span class="va">RMprecip</span><span class="op">$</span><span class="va">elev</span><span class="op">)</span></span></span>
<span class="r-in"><span>  </span></span>
<span class="r-in"><span><span class="co"># NOTE: out$d[4] is the estimated elevation coefficient</span></span></span>
<span class="r-in"><span><span class="co"># it is easy to get the smooth surface separate from the elevation.</span></span></span>
<span class="r-in"><span>  <span class="va">out.p</span><span class="op">&lt;-</span><span class="fu"><a href="predictSurface.html">predictSurface</a></span><span class="op">(</span> <span class="va">out</span>, drop.Z<span class="op">=</span><span class="cn">TRUE</span><span class="op">)</span></span></span>
<span class="r-in"><span>  <span class="fu"><a href="fields-internal.html">surface</a></span><span class="op">(</span> <span class="va">out.p</span><span class="op">)</span></span></span>
<span class="r-in"><span>  <span class="fu"><a href="US.html">US</a></span><span class="op">(</span> add<span class="op">=</span><span class="cn">TRUE</span>, col<span class="op">=</span><span class="st">"grey"</span><span class="op">)</span></span></span>
<span class="r-in"><span>  </span></span>
<span class="r-in"><span><span class="co"># and if the estimate is of high resolution and you get by with </span></span></span>
<span class="r-in"><span><span class="co"># a simple discretizing -- does not work in this case!</span></span></span>
<span class="r-in"><span>  <span class="fu"><a href="quilt.plot.html">quilt.plot</a></span><span class="op">(</span> <span class="va">out</span><span class="op">$</span><span class="va">x</span>, <span class="va">out</span><span class="op">$</span><span class="va">fitted.values</span><span class="op">)</span></span></span>
<span class="r-in"><span>  </span></span>
<span class="r-in"><span><span class="co">#</span></span></span>
<span class="r-in"><span><span class="co"># the exact way to do this is evaluate the estimate</span></span></span>
<span class="r-in"><span><span class="co"># on a grid where you also have elevations </span></span></span>
<span class="r-in"><span><span class="co"># An elevation DEM from the PRISM climate data product (4km resolution)</span></span></span>
<span class="r-in"><span>  <span class="fu"><a href="https://rdrr.io/r/utils/data.html" class="external-link">data</a></span><span class="op">(</span><span class="va">RMelevation</span><span class="op">)</span>  </span></span>
<span class="r-in"><span>  <span class="va">grid.list</span><span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/list.html" class="external-link">list</a></span><span class="op">(</span> x<span class="op">=</span><span class="va">RMelevation</span><span class="op">$</span><span class="va">x</span>, y<span class="op">=</span> <span class="va">RMelevation</span><span class="op">$</span><span class="va">y</span><span class="op">)</span></span></span>
<span class="r-in"><span>  <span class="va">fit.full</span><span class="op">&lt;-</span> <span class="fu"><a href="predictSurface.html">predictSurface</a></span><span class="op">(</span> <span class="va">out</span>, <span class="va">grid.list</span>, ZGrid<span class="op">=</span> <span class="va">RMelevation</span><span class="op">)</span></span></span>
<span class="r-in"><span>  </span></span>
<span class="r-in"><span><span class="co"># this is the linear fixed part of the second spatial model:</span></span></span>
<span class="r-in"><span><span class="co"># lon,lat and elevation</span></span></span>
<span class="r-in"><span>  <span class="va">fit.fixed</span><span class="op">&lt;-</span> <span class="fu"><a href="predictSurface.html">predictSurface</a></span><span class="op">(</span> <span class="va">out</span>, <span class="va">grid.list</span>, just.fixed<span class="op">=</span><span class="cn">TRUE</span>,</span></span>
<span class="r-in"><span>                   ZGrid<span class="op">=</span> <span class="va">RMelevation</span><span class="op">)</span></span></span>
<span class="r-in"><span>                   </span></span>
<span class="r-in"><span><span class="co"># This is the smooth part but also with the linear lon lat terms. </span></span></span>
<span class="r-in"><span>  <span class="va">fit.smooth</span><span class="op">&lt;-</span><span class="fu"><a href="predictSurface.html">predictSurface</a></span><span class="op">(</span> <span class="va">out</span>, <span class="va">grid.list</span>, drop.Z<span class="op">=</span><span class="cn">TRUE</span><span class="op">)</span></span></span>
<span class="r-in"><span>  </span></span>
<span class="r-in"><span><span class="co">#</span></span></span>
<span class="r-in"><span>  <span class="fu"><a href="set.panel.html">set.panel</a></span><span class="op">(</span> <span class="fl">3</span>,<span class="fl">1</span><span class="op">)</span></span></span>
<span class="r-in"><span>  </span></span>
<span class="r-in"><span>  <span class="va">fit0</span><span class="op">&lt;-</span> <span class="fu"><a href="predictSurface.html">predictSurface</a></span><span class="op">(</span> <span class="va">out0</span>, <span class="va">grid.list</span><span class="op">)</span></span></span>
<span class="r-in"><span>  <span class="fu"><a href="image.plot.html">image.plot</a></span><span class="op">(</span> <span class="va">fit0</span><span class="op">)</span></span></span>
<span class="r-in"><span>  <span class="fu"><a href="https://rdrr.io/r/graphics/title.html" class="external-link">title</a></span><span class="op">(</span><span class="st">" first spatial model (w/o elevation)"</span><span class="op">)</span></span></span>
<span class="r-in"><span>  <span class="fu"><a href="image.plot.html">image.plot</a></span><span class="op">(</span> <span class="va">fit.fixed</span><span class="op">)</span></span></span>
<span class="r-in"><span>  <span class="fu"><a href="https://rdrr.io/r/graphics/title.html" class="external-link">title</a></span><span class="op">(</span><span class="st">" fixed part of second model (lon,lat,elev linear model)"</span><span class="op">)</span></span></span>
<span class="r-in"><span>  <span class="fu"><a href="US.html">US</a></span><span class="op">(</span> add<span class="op">=</span><span class="cn">TRUE</span><span class="op">)</span></span></span>
<span class="r-in"><span>  <span class="fu"><a href="image.plot.html">image.plot</a></span><span class="op">(</span> <span class="va">fit.full</span><span class="op">)</span></span></span>
<span class="r-in"><span>  <span class="fu"><a href="https://rdrr.io/r/graphics/title.html" class="external-link">title</a></span><span class="op">(</span><span class="st">"full prediction second model"</span><span class="op">)</span></span></span>
<span class="r-in"><span>  <span class="fu"><a href="set.panel.html">set.panel</a></span><span class="op">(</span><span class="op">)</span></span></span>
<span class="r-in"><span><span class="op">}</span></span></span>
<span class="r-in"><span><span class="co">### </span></span></span>
<span class="r-in"><span><span class="co">### fast Tps</span></span></span>
<span class="r-in"><span><span class="co"># m=2   p= 2m-d= 2</span></span></span>
<span class="r-in"><span><span class="co">#</span></span></span>
<span class="r-in"><span><span class="co"># Note: aRange = 3 degrees is a very generous taper range. </span></span></span>
<span class="r-in"><span><span class="co"># Use some trial aRange value with rdist.nearest to determine a</span></span></span>
<span class="r-in"><span><span class="co"># a useful taper. Some empirical studies suggest that in the </span></span></span>
<span class="r-in"><span><span class="co"># interpolation case in 2 d the taper should be large enough to </span></span></span>
<span class="r-in"><span><span class="co"># about 20 non zero nearest neighbors for every location.</span></span></span>
<span class="r-in"><span></span></span>
<span class="r-in"><span>  <span class="va">out2</span><span class="op">&lt;-</span> <span class="fu">fastTps</span><span class="op">(</span> <span class="va">RMprecip</span><span class="op">$</span><span class="va">x</span>,<span class="va">RMprecip</span><span class="op">$</span><span class="va">y</span>,m<span class="op">=</span><span class="fl">2</span>, aRange<span class="op">=</span><span class="fl">3.0</span>, </span></span>
<span class="r-in"><span>                      profileLambda<span class="op">=</span><span class="cn">FALSE</span><span class="op">)</span></span></span>
<span class="r-in"><span></span></span>
<span class="r-in"><span><span class="co"># note that fastTps produces a object of classes  spatialProcess and mKrig</span></span></span>
<span class="r-in"><span><span class="co"># so one can use all the </span></span></span>
<span class="r-in"><span><span class="co"># the overloaded functions that are defined for these classes.</span></span></span>
<span class="r-in"><span><span class="co"># predict, predictSE, plot, sim.spatialProcess </span></span></span>
<span class="r-in"><span><span class="co"># summary of what happened note estimate of effective degrees of </span></span></span>
<span class="r-in"><span><span class="co"># freedom</span></span></span>
<span class="r-in"><span><span class="co"># profiling on lambda has been turned off to make this run quickly</span></span></span>
<span class="r-in"><span><span class="co"># but it is suggested that one examines the the profile likelihood over lambda</span></span></span>
<span class="r-in"><span>  </span></span>
<span class="r-in"><span>  <span class="fu"><a href="https://rdrr.io/r/base/print.html" class="external-link">print</a></span><span class="op">(</span> <span class="va">out2</span><span class="op">)</span></span></span>
<span class="r-out co"><span class="r-pr">#&gt;</span> CALL:</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> fastTps(x = RMprecip$x, Y = RMprecip$y, m = 2, aRange = 3, profileLambda = FALSE)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>  SUMMARY OF MODEL FIT:</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>                                                              </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>  Number of Observations:                    806              </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>  Degree of polynomial in fixed part:        1                </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>  Total number of parameters in fixed part:  3                </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>  sigma Process stan. dev:                   22.53            </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>  tau  Nugget stan. dev:                     25.99            </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>  lambda   tau^2/sigma^2:                    1.33             </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>  aRange parameter (in units of distance):   3                </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>  Approx.  degrees of freedom for curve      105.9            </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     Standard Error of df estimate:          2.338            </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>  log Likelihood:                            -3871.12060412435</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>  log Likelihood REML:                       -3879.17851011222</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>  ESTIMATED COEFFICIENTS FOR FIXED PART:</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>    estimate       SE    pValue</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> d1  756.400 106.5000 1.202e-12</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> d2    4.425   0.9369 2.317e-06</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> d3   -5.471   1.1070 7.698e-07</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>  COVARIANCE MODEL: wendland.cov</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>    Non-default covariance arguments and their values </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> k :</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> [1] 2</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> Dist.args :</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> $method</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> [1] "euclidean"</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> aRange :</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> [1] 3</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> Nonzero entries in covariance matrix  119816</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> SUMMARY FROM Max. Likelihood ESTIMATION:</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> Parameters found from optim: </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   lambda </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> 1.330438 </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> Approx. confidence intervals for MLE(s) </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>         lower95% upper95%</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> lambda 0.9586872 1.846342</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>  Note: MLEs for  tau and sigma found analytically from lambda</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> Summary from estimation:</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> lnProfileLike.FULL lnProfileREML.FULL        lnLike.FULL        lnREML.FULL </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>       -3871.120604       -3879.178510                 NA                 NA </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             lambda                tau             sigma2             aRange </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>           1.330438          25.991494         507.771046           3.000000 </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             eff.df                GCV </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>         105.905726         774.682072 </span>
<span class="r-in"><span></span></span>
<span class="r-in"><span><span class="kw">if</span> <span class="op">(</span><span class="cn">FALSE</span><span class="op">)</span> <span class="op">{</span></span></span>
<span class="r-in"><span><span class="fu"><a href="set.panel.html">set.panel</a></span><span class="op">(</span> <span class="fl">1</span>,<span class="fl">2</span><span class="op">)</span></span></span>
<span class="r-in"><span><span class="fu"><a href="fields-internal.html">surface</a></span><span class="op">(</span> <span class="va">out2</span><span class="op">)</span></span></span>
<span class="r-in"><span></span></span>
<span class="r-in"><span><span class="co">#</span></span></span>
<span class="r-in"><span><span class="co"># now use great circle distance for this smooth </span></span></span>
<span class="r-in"><span><span class="co"># Here "aRange" for the taper support is the great circle distance in degrees latitude.</span></span></span>
<span class="r-in"><span><span class="co"># Typically for data analysis it more convenient to think in degrees. A degree of</span></span></span>
<span class="r-in"><span><span class="co"># latitude is about 68 miles (111 km).</span></span></span>
<span class="r-in"><span><span class="co">#</span></span></span>
<span class="r-in"><span><span class="fu">fastTps</span><span class="op">(</span> <span class="va">RMprecip</span><span class="op">$</span><span class="va">x</span>,<span class="va">RMprecip</span><span class="op">$</span><span class="va">y</span>,m<span class="op">=</span><span class="fl">2</span>, lon.lat<span class="op">=</span><span class="cn">TRUE</span>, aRange<span class="op">=</span> <span class="fl">210</span> <span class="op">)</span> <span class="op">-&gt;</span> <span class="va">out3</span></span></span>
<span class="r-in"><span><span class="fu"><a href="https://rdrr.io/r/base/print.html" class="external-link">print</a></span><span class="op">(</span> <span class="va">out3</span><span class="op">)</span>  <span class="co"># note the effective degrees of freedom is different.</span></span></span>
<span class="r-in"><span><span class="fu"><a href="fields-internal.html">surface</a></span><span class="op">(</span><span class="va">out3</span><span class="op">)</span></span></span>
<span class="r-in"><span></span></span>
<span class="r-in"><span><span class="fu"><a href="set.panel.html">set.panel</a></span><span class="op">(</span><span class="op">)</span></span></span>
<span class="r-in"><span><span class="op">}</span></span></span>
<span class="r-in"><span></span></span>
<span class="r-in"><span><span class="kw">if</span> <span class="op">(</span><span class="cn">FALSE</span><span class="op">)</span> <span class="op">{</span></span></span>
<span class="r-in"><span><span class="co">#</span></span></span>
<span class="r-in"><span><span class="co"># simulation reusing Tps/Krig object</span></span></span>
<span class="r-in"><span><span class="co">#</span></span></span>
<span class="r-in"><span><span class="va">fit</span><span class="op">&lt;-</span> <span class="fu">Tps</span><span class="op">(</span> <span class="va">rat.diet</span><span class="op">$</span><span class="va">t</span>, <span class="va">rat.diet</span><span class="op">$</span><span class="va">trt</span><span class="op">)</span></span></span>
<span class="r-in"><span><span class="va">true</span><span class="op">&lt;-</span> <span class="va">fit</span><span class="op">$</span><span class="va">fitted.values</span></span></span>
<span class="r-in"><span><span class="va">N</span><span class="op">&lt;-</span>  <span class="fu"><a href="https://rdrr.io/r/base/length.html" class="external-link">length</a></span><span class="op">(</span> <span class="va">fit</span><span class="op">$</span><span class="va">y</span><span class="op">)</span></span></span>
<span class="r-in"><span><span class="va">temp</span><span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/matrix.html" class="external-link">matrix</a></span><span class="op">(</span>  <span class="cn">NA</span>, ncol<span class="op">=</span><span class="fl">50</span>, nrow<span class="op">=</span><span class="va">N</span><span class="op">)</span></span></span>
<span class="r-in"><span><span class="va">tau</span><span class="op">&lt;-</span> <span class="va">fit</span><span class="op">$</span><span class="va">tauHat.GCV</span></span></span>
<span class="r-in"><span><span class="kw">for</span> <span class="op">(</span>  <span class="va">k</span> <span class="kw">in</span> <span class="fl">1</span><span class="op">:</span><span class="fl">50</span><span class="op">)</span><span class="op">{</span></span></span>
<span class="r-in"><span><span class="va">ysim</span><span class="op">&lt;-</span> <span class="va">true</span> <span class="op">+</span> <span class="va">tau</span><span class="op">*</span> <span class="fu"><a href="https://rdrr.io/r/stats/Normal.html" class="external-link">rnorm</a></span><span class="op">(</span><span class="va">N</span><span class="op">)</span> </span></span>
<span class="r-in"><span><span class="va">temp</span><span class="op">[</span>,<span class="va">k</span><span class="op">]</span><span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/stats/predict.html" class="external-link">predict</a></span><span class="op">(</span><span class="va">fit</span>, y<span class="op">=</span> <span class="va">ysim</span><span class="op">)</span></span></span>
<span class="r-in"><span><span class="op">}</span></span></span>
<span class="r-in"><span><span class="fu"><a href="https://rdrr.io/r/graphics/matplot.html" class="external-link">matplot</a></span><span class="op">(</span> <span class="va">fit</span><span class="op">$</span><span class="va">x</span>, <span class="va">temp</span>, type<span class="op">=</span><span class="st">"l"</span><span class="op">)</span></span></span>
<span class="r-in"><span></span></span>
<span class="r-in"><span><span class="op">}</span></span></span>
<span class="r-in"><span><span class="co"># </span></span></span>
<span class="r-in"><span><span class="co">#4-d example </span></span></span>
<span class="r-in"><span><span class="va">fit</span><span class="op">&lt;-</span> <span class="fu">Tps</span><span class="op">(</span><span class="va">BD</span><span class="op">[</span>,<span class="fl">1</span><span class="op">:</span><span class="fl">4</span><span class="op">]</span>,<span class="va">BD</span><span class="op">$</span><span class="va">lnya</span>,scale.type<span class="op">=</span><span class="st">"range"</span><span class="op">)</span> </span></span>
<span class="r-in"><span></span></span>
<span class="r-in"><span><span class="co"># plots fitted surface and contours </span></span></span>
<span class="r-in"><span><span class="co"># default is to hold 3rd and 4th fixed at median values </span></span></span>
<span class="r-in"><span></span></span>
<span class="r-in"><span><span class="fu"><a href="fields-internal.html">surface</a></span><span class="op">(</span><span class="va">fit</span><span class="op">)</span>   </span></span>
<span class="r-plt img"><img src="Tps-5.png" alt="" width="700" height="433"></span>
<span class="r-in"><span></span></span>
<span class="r-in"><span></span></span>
<span class="r-in"><span></span></span>
</code></pre></div>
    </div>
  </div>
  <div class="col-md-3 hidden-xs hidden-sm" id="pkgdown-sidebar">
    <nav id="toc" data-toggle="toc" class="sticky-top"><h2 data-toc-skip>Contents</h2>
    </nav></div>
</div>


      <footer><div class="copyright">
  <p></p><p>Developed by Douglas Nychka, Reinhard Furrer, John Paige, Stephan Sain, Florian Gerber, Matthew Iverson.</p>
</div>

<div class="pkgdown">
  <p></p><p>Site built with <a href="https://pkgdown.r-lib.org/" class="external-link">pkgdown</a> 2.0.7.</p>
</div>

      </footer></div>

  


  

  </body></html>

