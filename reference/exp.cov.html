<!DOCTYPE html>
<!-- Generated by pkgdown: do not edit by hand --><html lang="en"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0"><title>Exponential  family, radial basis 
functions,cubic spline,  compactly  supported Wendland family and 
stationary covariances. — Covariance functions • fields</title><!-- jquery --><script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js" integrity="sha256-CSXorXvZcTkaix6Yvo6HppcZGetbYMGWSFlBw8HfCJo=" crossorigin="anonymous"></script><!-- Bootstrap --><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/3.4.1/css/bootstrap.min.css" integrity="sha256-bZLfwXAP04zRMK2BjiO8iu9pf4FbLqX6zitd+tIvLhE=" crossorigin="anonymous"><script src="https://cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/3.4.1/js/bootstrap.min.js" integrity="sha256-nuL8/2cJ5NDSSwnKD8VqreErSWHtnEP9E7AySL+1ev4=" crossorigin="anonymous"></script><!-- bootstrap-toc --><link rel="stylesheet" href="../bootstrap-toc.css"><script src="../bootstrap-toc.js"></script><!-- Font Awesome icons --><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.12.1/css/all.min.css" integrity="sha256-mmgLkCYLUQbXn0B1SRqzHar6dCnv9oZFPEC1g1cwlkk=" crossorigin="anonymous"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.12.1/css/v4-shims.min.css" integrity="sha256-wZjR52fzng1pJHwx4aV2AO3yyTOXrcDW7jBpJtTwVxw=" crossorigin="anonymous"><!-- clipboard.js --><script src="https://cdnjs.cloudflare.com/ajax/libs/clipboard.js/2.0.6/clipboard.min.js" integrity="sha256-inc5kl9MA1hkeYUt+EC3BhlIgyp/2jDIyBLS6k3UxPI=" crossorigin="anonymous"></script><!-- headroom.js --><script src="https://cdnjs.cloudflare.com/ajax/libs/headroom/0.11.0/headroom.min.js" integrity="sha256-AsUX4SJE1+yuDu5+mAVzJbuYNPHj/WroHuZ8Ir/CkE0=" crossorigin="anonymous"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/headroom/0.11.0/jQuery.headroom.min.js" integrity="sha256-ZX/yNShbjqsohH1k95liqY9Gd8uOiE1S4vZc+9KQ1K4=" crossorigin="anonymous"></script><!-- pkgdown --><link href="../pkgdown.css" rel="stylesheet"><script src="../pkgdown.js"></script><meta property="og:title" content="Exponential  family, radial basis 
functions,cubic spline,  compactly  supported Wendland family and 
stationary covariances. — Covariance functions"><meta property="og:description" content="Given two sets of locations these functions compute the cross covariance matrix for
some covariance families. In addition these functions can take advantage 
of spareness, implement more efficient multiplcation of the 
cross covariance by a vector or matrix and also return a marginal 
variance to be consistent with calls by the Krig function.
stationary.cov and Exp.cov have additional arguments for 
precomputed distance matrices and for calculating only the upper triangle 
and diagonal of the output covariance matrix to save time.  Also, they 
support using the rdist function with compact=TRUE or input 
distance matrices in compact form, where only the upper triangle of the 
distance matrix is used to save time.
Note: These functions have been been renamed from the previous fields functions
using 'Exp' in place of 'exp' to avoid conflict with the generic exponential 
function (exp(...))in R."><!-- mathjax --><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js" integrity="sha256-nvJJv9wWKEm88qvoQl9ekL2J+k/RWIsaSScxxlsrv8k=" crossorigin="anonymous"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/config/TeX-AMS-MML_HTMLorMML.js" integrity="sha256-84DKXVJXs0/F8OTMzX4UR909+jtl4G7SPypPavF+GfA=" crossorigin="anonymous"></script><!--[if lt IE 9]>
<script src="https://oss.maxcdn.com/html5shiv/3.7.3/html5shiv.min.js"></script>
<script src="https://oss.maxcdn.com/respond/1.4.2/respond.min.js"></script>
<![endif]--></head><body data-spy="scroll" data-target="#toc">
    

    <div class="container template-reference-topic">
      <header><div class="navbar navbar-default navbar-fixed-top" role="navigation">
  <div class="container">
    <div class="navbar-header">
      <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar" aria-expanded="false">
        <span class="sr-only">Toggle navigation</span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
      <span class="navbar-brand">
        <a class="navbar-link" href="../index.html">fields</a>
        <span class="version label label-default" data-toggle="tooltip" data-placement="bottom" title="">14.1</span>
      </span>
    </div>

    <div id="navbar" class="navbar-collapse collapse">
      <ul class="nav navbar-nav"><li>
  <a href="../reference/index.html">Reference</a>
</li>
<li class="dropdown">
  <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" data-bs-toggle="dropdown" aria-expanded="false">
    Articles
     
    <span class="caret"></span>
  </a>
  <ul class="dropdown-menu" role="menu"><li>
      <a href="../articles/Tps.html">Tps usage illustration</a>
    </li>
    <li>
      <a href="../articles/fastTps.html">fastTps</a>
    </li>
    <li>
      <a href="../articles/predictSurface.html">predictSurface</a>
    </li>
  </ul></li>
      </ul><ul class="nav navbar-nav navbar-right"><li>
  <a href="https://github.com/dnychka/fieldsRPackage/" class="external-link">
    <span class="fab fa-github fa-lg"></span>
     
  </a>
</li>
      </ul></div><!--/.nav-collapse -->
  </div><!--/.container -->
</div><!--/.navbar -->

      

      </header><div class="row">
  <div class="col-md-9 contents">
    <div class="page-header">
    <h1>Exponential  family, radial basis 
functions,cubic spline,  compactly  supported Wendland family and 
stationary covariances.</h1>
    
    <div class="hidden name"><code>exp.cov.Rd</code></div>
    </div>

    <div class="ref-description">
    <p>Given two sets of locations these functions compute the cross covariance matrix for
some covariance families. In addition these functions can take advantage 
of spareness, implement more efficient multiplcation of the 
cross covariance by a vector or matrix and also return a marginal 
variance to be consistent with calls by the Krig function.</p>
<p><code>stationary.cov</code> and <code>Exp.cov</code> have additional arguments for 
precomputed distance matrices and for calculating only the upper triangle 
and diagonal of the output covariance matrix to save time.  Also, they 
support using the <code>rdist</code> function with <code>compact=TRUE</code> or input 
distance matrices in compact form, where only the upper triangle of the 
distance matrix is used to save time.</p>
<p>Note: These functions have been been renamed from the previous fields functions
using 'Exp' in place of 'exp' to avoid conflict with the generic exponential 
function (<code>exp(...)</code>)in R.</p>
    </div>

    <div id="ref-usage">
    <div class="sourceCode"><pre class="sourceCode r"><code><span><span class="fu">Exp.cov</span><span class="op">(</span><span class="va">x1</span>, x2<span class="op">=</span><span class="cn">NULL</span>, aRange <span class="op">=</span> <span class="fl">1</span>, p<span class="op">=</span><span class="fl">1</span>, distMat <span class="op">=</span> <span class="cn">NA</span>, </span>
<span>  C <span class="op">=</span> <span class="cn">NA</span>, marginal <span class="op">=</span> <span class="cn">FALSE</span>, onlyUpper<span class="op">=</span><span class="cn">FALSE</span>, theta<span class="op">=</span><span class="cn">NULL</span><span class="op">)</span></span>
<span></span>
<span><span class="fu">Exp.simple.cov</span><span class="op">(</span><span class="va">x1</span>, <span class="va">x2</span>, aRange <span class="op">=</span><span class="fl">1</span>, C<span class="op">=</span><span class="cn">NA</span>,marginal<span class="op">=</span><span class="cn">FALSE</span>, theta<span class="op">=</span><span class="cn">NULL</span><span class="op">)</span></span>
<span></span>
<span><span class="fu">Rad.cov</span><span class="op">(</span><span class="va">x1</span>, <span class="va">x2</span>, p <span class="op">=</span> <span class="fl">1</span>, m<span class="op">=</span><span class="cn">NA</span>, with.log <span class="op">=</span> <span class="cn">TRUE</span>, with.constant <span class="op">=</span> <span class="cn">TRUE</span>, </span>
<span>               C<span class="op">=</span><span class="cn">NA</span>,marginal<span class="op">=</span><span class="cn">FALSE</span>, derivative<span class="op">=</span><span class="fl">0</span><span class="op">)</span></span>
<span></span>
<span><span class="fu">cubic.cov</span><span class="op">(</span><span class="va">x1</span>, <span class="va">x2</span>, aRange <span class="op">=</span> <span class="fl">1</span>, C<span class="op">=</span><span class="cn">NA</span>, marginal<span class="op">=</span><span class="cn">FALSE</span>, theta<span class="op">=</span><span class="cn">NULL</span><span class="op">)</span> </span>
<span></span>
<span><span class="fu">Rad.simple.cov</span><span class="op">(</span><span class="va">x1</span>, <span class="va">x2</span>, p<span class="op">=</span><span class="fl">1</span>, with.log <span class="op">=</span> <span class="cn">TRUE</span>, with.constant <span class="op">=</span> <span class="cn">TRUE</span>, </span>
<span>               C <span class="op">=</span> <span class="cn">NA</span>, marginal<span class="op">=</span><span class="cn">FALSE</span><span class="op">)</span></span>
<span></span>
<span><span class="fu">stationary.cov</span><span class="op">(</span><span class="va">x1</span>, x2<span class="op">=</span><span class="cn">NULL</span>, Covariance <span class="op">=</span> <span class="st">"Exponential"</span>, Distance <span class="op">=</span> <span class="st">"rdist"</span>, </span>
<span>  Dist.args <span class="op">=</span> <span class="cn">NULL</span>, aRange <span class="op">=</span> <span class="fl">1</span>, V <span class="op">=</span> <span class="cn">NULL</span>, C <span class="op">=</span> <span class="cn">NA</span>, marginal <span class="op">=</span> <span class="cn">FALSE</span>, </span>
<span>  derivative <span class="op">=</span> <span class="fl">0</span>, distMat <span class="op">=</span> <span class="cn">NA</span>, onlyUpper <span class="op">=</span> <span class="cn">FALSE</span>, theta<span class="op">=</span><span class="cn">NULL</span>, <span class="va">...</span><span class="op">)</span></span>
<span></span>
<span><span class="fu">stationary.taper.cov</span><span class="op">(</span><span class="va">x1</span>, <span class="va">x2</span>, Covariance<span class="op">=</span><span class="st">"Exponential"</span>, </span>
<span>           Taper<span class="op">=</span><span class="st">"Wendland"</span>, </span>
<span>           Dist.args<span class="op">=</span><span class="cn">NULL</span>, Taper.args<span class="op">=</span><span class="cn">NULL</span>, </span>
<span>           aRange<span class="op">=</span><span class="fl">1.0</span>,V<span class="op">=</span><span class="cn">NULL</span>, C<span class="op">=</span><span class="cn">NA</span>, marginal<span class="op">=</span><span class="cn">FALSE</span>,</span>
<span>           spam.format<span class="op">=</span><span class="cn">TRUE</span>,verbose<span class="op">=</span><span class="cn">FALSE</span>, theta<span class="op">=</span><span class="cn">NULL</span>,<span class="va">...</span><span class="op">)</span></span>
<span></span>
<span><span class="fu">wendland.cov</span><span class="op">(</span><span class="va">x1</span>, <span class="va">x2</span>, aRange <span class="op">=</span> <span class="fl">1</span>, V<span class="op">=</span><span class="cn">NULL</span>, k <span class="op">=</span> <span class="fl">2</span>, C <span class="op">=</span> <span class="cn">NA</span>, </span>
<span>             marginal <span class="op">=</span><span class="cn">FALSE</span>,Dist.args <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/list.html" class="external-link">list</a></span><span class="op">(</span>method <span class="op">=</span> <span class="st">"euclidean"</span><span class="op">)</span>, </span>
<span>             spam.format <span class="op">=</span> <span class="cn">TRUE</span>, derivative <span class="op">=</span> <span class="fl">0</span>, verbose<span class="op">=</span><span class="cn">FALSE</span>, theta<span class="op">=</span><span class="cn">NULL</span><span class="op">)</span></span></code></pre></div>
    </div>

    <div id="arguments">
    <h2>Arguments</h2>
    <dl><dt>x1</dt>
<dd><p>Matrix of first set of locations where each row gives the
coordinates of a particular point.</p></dd>


<dt>x2</dt>
<dd><p>Matrix of second set of locations where each row gives the
coordinatesof a particular point. If this is missing x1 is used.</p></dd>


<dt>aRange</dt>
<dd><p>Range (or scale) parameter. This should be a scalar (use
the V argument for other scaling options). Any distance calculated for
a covariance function is divided by aRange before the covariance function
is evaluated.</p></dd>


<dt>theta</dt>
<dd><p>Old version of the aRange parameter. If passed will be copied to aRange.</p></dd>

 
<dt>V</dt>
<dd><p>A matrix that describes the inverse linear transformation of
the coordinates before distances are found.  In R code this
transformation is: <code>x1 %*% t(solve(V))</code> Default is NULL, that
is the transformation is just dividing distance by the scalar value
<code>aRange</code>. See Details below.  If one has a vector of "aRange's"
that are the scaling for each coordinate then just express this as
<code>V = diag(aRange)</code> in the call to this function.</p></dd>


<dt>C</dt>
<dd><p>A vector with the same length as the number of rows of x2.
If specified the covariance matrix will be multiplied by this vector.</p></dd>


<dt>marginal</dt>
<dd><p>If TRUE returns just the diagonal elements of the
covariance matrix using the <code>x1</code> locations. In this case this is
just 1.0. The marginal argument will trivial for this function is a
required argument and capability for all covariance functions used
with Krig.</p></dd>


<dt>p</dt>
<dd><p>Exponent in the exponential covariance family.  p=1 gives an
exponential and p=2 gives a Gaussian.  Default is the exponential
form.  For the radial basis function this is the exponent applied to
the distance between locations.</p></dd>

<dt>m</dt>
<dd><p>For the radial basis function p = 2m-d, with d being the dimension of the
locations, is the exponent applied to
the distance between locations. (m is a common way of parametrizing this exponent.)</p></dd>


<dt>with.constant</dt>
<dd><p>If TRUE includes complicated constant for radial
 basis functions.  See the function <code>radbad.constant</code> for more
 details. The default is TRUE, include the constant. Without the usual
 constant the lambda used here will differ by a constant from spline
 estimators ( e.g.  cubic smoothing splines) that use the
 constant. Also a negative value for the constant may be necessary to
 make the radial basis positive definite as opposed to negative
 definite.</p></dd>


<dt>with.log</dt>
<dd><p>If TRUE include a log term for even dimensions.  This
is needed to be a thin plate spline of integer order.</p></dd>


<dt>Covariance</dt>
<dd><p>Character string that is the name of the covariance
shape function for the distance between locations. Choices in fields
are <code>Exponential</code>, <code>Matern</code></p></dd>


<dt>Distance</dt>
<dd><p>Character string that is the name of the distance
function to use. Choices in fields are <code>rdist</code>,
<code>rdist.earth</code></p></dd>


<dt>Taper</dt>
<dd><p>Character string that is the name of the taper function
to use. Choices in fields are listed in help(taper).</p></dd>


<dt>Dist.args</dt>
<dd><p>A list of optional arguments to pass to the Distance
function.</p></dd>


<dt>Taper.args</dt>
<dd><p>A list of optional arguments to pass to the Taper
function. <code>aRange</code> should always be the name for the range (or
scale) paremeter.</p></dd>


<dt>spam.format</dt>
<dd><p>If TRUE returns matrix in sparse matrix format
implemented in the spam package. If FALSE just returns a full
matrix.</p></dd>


<dt>k</dt>
<dd><p>The order of the Wendland covariance function.  See help on
 Wendland.</p></dd>


 <dt>derivative</dt>
<dd><p>If nonzero evaluates the partials of the
covariance function at locations x1. This must be used with  the "C" option
and is mainly called from within a predict function.  The partial
derivative is taken with respect to <code>x1</code>.</p></dd>


<dt>verbose</dt>
<dd><p>If TRUE prints out some useful information for
debugging.</p></dd>


<dt>distMat</dt>
<dd><p>If the distance matrix between <code>x1</code> and <code>x2</code> has already been 
computed, it can be passed via this argument so it won't need to be 
recomputed.</p></dd>

<dt>onlyUpper</dt>
<dd><p>For internal use only, not meant to be set by the user.  Automatically 
set to <code>TRUE</code> by <code>mKrigMLEJoint</code> or <code>mKrigMLEGrid</code> if 
<code>lambda.profile</code> is set to <code>TRUE</code>, but set to <code>FALSE</code> 
for the final parameter fit so output is compatible with rest of 
<code>fields</code>.</p>
<p>If <code>TRUE</code>, only the upper triangle and diagonal of the covariance 
matrix is computed to save time (although if a non-compact distance 
matrix is used, the onlyUpper argument is set to FALSE).  If <code>FALSE</code>, 
the entire covariance matrix is computed.  In general, it should 
only be set to <code>TRUE</code> for <code>mKrigMLEJoint</code> and <code>mKrigMLEGrid</code>, 
and the default is set to <code>FALSE</code> so it is compatible with all of
<code>fields</code>.</p></dd>


<dt>...</dt>
<dd><p>Any other arguments that will be passed to the
covariance function. e.g. <code>smoothness</code> for the Matern.</p></dd>
  </dl></div>
    <div id="value">
    <h2>Value</h2>
    <p>If the argument C is NULL the cross covariance matrix is
returned.  In general if nrow(x1)=m and nrow(x2)=n then the returned
matrix will be mXn.  Moreover, if x1 is equal to x2 then this is the
covariance matrix for this set of locations.</p>



<p>If C is a vector of length n, then returned value is the
multiplication of the cross covariance matrix with this vector.</p>
 

    </div>
    <div id="details">
    <h2>Details</h2>
    <p>For purposes of illustration, the function
<code>Exp.cov.simple</code> is provided in fields as a simple example and
implements the R code discussed below.  List this function out as a
way to see the standard set of arguments that fields uses to define a
covariance function.  It can also serve as a template for creating new
covariance functions for the <code>Krig</code> and <code>mKrig</code>
functions. Also see the higher level function <code>stationary.cov</code> to
mix and match different covariance shapes and distance functions.</p>
<p>A common scaling for stationary covariances: If <code>x1</code> and
 <code>x2</code> are matrices where <code>nrow(x1)=m</code> and <code>nrow(x2)=n</code>
 then this function will return a mXn matrix where the (i,j) element
 is the covariance between the locations <code>x1[i,]</code> and
 <code>x2[j,]</code>. The exponential covariance function is computed as
 exp( -(D.ij)) where D.ij is a distance between <code>x1[i,]</code> and
 <code>x2[j,]</code> but having first been scaled by aRange. Specifically if
 <code>aRange</code> is a matrix to represent a linear transformation of the
 coordinates, then let <code>u= x1%*% t(solve( aRange))</code> and <code>v=
 x2%*% t(solve(aRange))</code>.  Form the mXn distance matrix with
 elements:</p>
<p><code>D[i,j] = sqrt( sum( ( u[i,] - v[j,])**2 ) )</code>.</p>
<p>and the cross covariance matrix is found by <code>exp(-D)</code>.  The
tapered form (ignoring scaling parameters) is a matrix with i,j entry
<code>exp(-D[i,j])*T(D[i,j])</code>. With T being a positive definite
tapering function that is also assumed to be zero beyond 1.</p>
<p>Note that if aRange is a scalar then this defines an isotropic
covariance function and the functional form is essentially
<code>exp(-D/aRange)</code>.</p>
<p>Implementation: The function <code>r.dist</code> is a useful FIELDS function
that finds the cross Euclidean distance matrix (D defined above) for
two sets of locations. Thus in compact R code we have</p>
<p>exp(-rdist(u, v))</p>
<p>Note that this function must also support two other kinds of calls:</p>
<p>If marginal is TRUE then just the diagonal elements are returned (in R
code <code>diag( exp(-rdist(u,u)) )</code>).</p>
<p>If C is passed then the returned value is <code> exp(-rdist(u, v))
%*% C</code>.</p>

<p>Some details on particular covariance functions:</p>
<dl><dt>Radial basis functions (<code>Rad.cov</code>:</dt>
<dd><p>The
functional form is Constant* rdist(u, v)**p for odd dimensions and
Constant* rdist(u,v)**p * log( rdist(u,v) ) For an m th order thin plate
spline in d dimensions p= 2*m-d and must be positive. The constant,
depending on m and d, is coded in the fields function
<code>radbas.constant</code>. This form is only a generalized covariance
function -- it is only positive definite when restricted to linear
subspace.  See <code>Rad.simple.cov</code> for a coding of the radial basis
functions in R code.</p></dd>


<dt>Stationary covariance <code>stationary.cov</code>:</dt>
<dd><p>Here the
computation is to apply the function Covariance to the distances found
by the Distance function.  For example</p>
<p><code>Exp.cov(x1,x2, aRange=MyTheta)</code></p>
<p>and</p>
<p><code>stationary.cov( x1,x2, aRange=MyTheta, Distance= "rdist",
Covariance="Exponential")</code></p>
<p>are the same. This also the same as</p>
<p><code>stationary.cov( x1,x2, aRange=MyTheta, Distance= "rdist",
Covariance="Matern",smoothness=.5)</code>.</p></dd>


<dt>Stationary tapered covariance <code>stationary.taper.cov</code>:</dt>
<dd><p>The
resulting cross covariance is the direct or Shure product of the
tapering function and the covariance. In R code given location
matrices, <code>x1</code> and <code>x2</code> and using Euclidean distance.</p> 
<p><code>Covariance(rdist( x1, x2)/aRange)*Taper( rdist( x1,
x2)/Taper.args$aRange)</code></p>
<p>By convention, the <code>Taper</code> function is assumed to be identically
zero outside the interval [0,1]. Some efficiency is introduced within
the function to search for pairs of locations that are nonzero with
respect to the Taper. This is done by the SPAM function
<code>nearest.dist</code>.  This search may find more nonzero pairs than
dimensioned internally and SPAM will try to increase the space. One
can also reset the SPAM options to avoid these warnings.  For
spam.format TRUE the multiplication with the <code>C</code> argument is done
with the spam sparse multiplication routines through the "overloading"
of the <code>%*%</code> operator.</p></dd>



</dl><p>About the FORTRAN: The actual function <code>Exp.cov</code> and 
<code>Rad.cov</code> call FORTRAN to 
make the evaluation more efficient this is especially important when the 
C argument is supplied. So unfortunately the actual production code in 
Exp.cov is not as crisp as the R code sketched above. See  
<code>Rad.simple.cov</code> for a R coding of the radial basis functions.</p>
    </div>
    <div id="see-also">
    <h2>See also</h2>
    <div class="dont-index"><p>Krig, rdist, rdist.earth, gauss.cov, Exp.image.cov, Exponential, Matern, 
Wendland.cov, mKrig</p></div>
    </div>

    <div id="ref-examples">
    <h2>Examples</h2>
    <div class="sourceCode"><pre class="sourceCode r"><code><span class="r-in"><span><span class="co"># exponential covariance matrix ( marginal variance =1) for the ozone</span></span></span>
<span class="r-in"><span><span class="co">#locations </span></span></span>
<span class="r-in"><span><span class="va">out</span><span class="op">&lt;-</span> <span class="fu">Exp.cov</span><span class="op">(</span> <span class="va">ChicagoO3</span><span class="op">$</span><span class="va">x</span>, aRange<span class="op">=</span><span class="fl">100</span><span class="op">)</span></span></span>
<span class="r-in"><span></span></span>
<span class="r-in"><span><span class="co"># out is a 20X20 matrix</span></span></span>
<span class="r-in"><span></span></span>
<span class="r-in"><span><span class="va">out2</span><span class="op">&lt;-</span> <span class="fu">Exp.cov</span><span class="op">(</span> <span class="va">ChicagoO3</span><span class="op">$</span><span class="va">x</span><span class="op">[</span><span class="fl">6</span><span class="op">:</span><span class="fl">20</span>,<span class="op">]</span>,<span class="va">ChicagoO3</span><span class="op">$</span><span class="va">x</span><span class="op">[</span><span class="fl">1</span><span class="op">:</span><span class="fl">2</span>,<span class="op">]</span>, aRange<span class="op">=</span><span class="fl">100</span><span class="op">)</span></span></span>
<span class="r-in"><span><span class="co"># out2 is 15X2 matrix </span></span></span>
<span class="r-in"><span></span></span>
<span class="r-in"><span><span class="co"># Kriging fit where the nugget variance is found by GCV </span></span></span>
<span class="r-in"><span><span class="co"># Matern covariance shape with range of 100.</span></span></span>
<span class="r-in"><span><span class="co"># </span></span></span>
<span class="r-in"><span></span></span>
<span class="r-in"><span><span class="va">fit</span><span class="op">&lt;-</span> <span class="fu"><a href="Krig.html">Krig</a></span><span class="op">(</span> <span class="va">ChicagoO3</span><span class="op">$</span><span class="va">x</span>, <span class="va">ChicagoO3</span><span class="op">$</span><span class="va">y</span>, Covariance<span class="op">=</span><span class="st">"Matern"</span>, aRange<span class="op">=</span><span class="fl">100</span>,smoothness<span class="op">=</span><span class="fl">2</span><span class="op">)</span></span></span>
<span class="r-in"><span></span></span>
<span class="r-in"><span><span class="fu"><a href="https://rdrr.io/r/utils/data.html" class="external-link">data</a></span><span class="op">(</span> <span class="va">ozone2</span><span class="op">)</span></span></span>
<span class="r-in"><span><span class="va">x</span><span class="op">&lt;-</span> <span class="va">ozone2</span><span class="op">$</span><span class="va">lon.lat</span></span></span>
<span class="r-in"><span><span class="va">y</span><span class="op">&lt;-</span> <span class="va">ozone2</span><span class="op">$</span><span class="va">y</span><span class="op">[</span><span class="fl">16</span>,<span class="op">]</span></span></span>
<span class="r-in"><span><span class="co"># Omit the NAs</span></span></span>
<span class="r-in"><span><span class="va">good</span><span class="op">&lt;-</span> <span class="op">!</span><span class="fu"><a href="https://rdrr.io/r/base/NA.html" class="external-link">is.na</a></span><span class="op">(</span> <span class="va">y</span><span class="op">)</span></span></span>
<span class="r-in"><span><span class="va">x</span><span class="op">&lt;-</span> <span class="va">x</span><span class="op">[</span><span class="va">good</span>,<span class="op">]</span></span></span>
<span class="r-in"><span><span class="va">y</span><span class="op">&lt;-</span> <span class="va">y</span><span class="op">[</span><span class="va">good</span><span class="op">]</span></span></span>
<span class="r-in"><span></span></span>
<span class="r-in"><span></span></span>
<span class="r-in"><span><span class="co"># example of calling the taper version directly </span></span></span>
<span class="r-in"><span><span class="co"># Note that default covariance is exponential and default taper is </span></span></span>
<span class="r-in"><span><span class="co"># Wendland (k=2).</span></span></span>
<span class="r-in"><span></span></span>
<span class="r-in"><span><span class="fu">stationary.taper.cov</span><span class="op">(</span> <span class="va">x</span><span class="op">[</span><span class="fl">1</span><span class="op">:</span><span class="fl">3</span>,<span class="op">]</span>,<span class="va">x</span><span class="op">[</span><span class="fl">1</span><span class="op">:</span><span class="fl">10</span>,<span class="op">]</span> , aRange<span class="op">=</span><span class="fl">1.5</span>, Taper.args<span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/list.html" class="external-link">list</a></span><span class="op">(</span>k<span class="op">=</span><span class="fl">2</span>,aRange<span class="op">=</span><span class="fl">2.0</span>,</span></span>
<span class="r-in"><span>                       dimension<span class="op">=</span><span class="fl">2</span><span class="op">)</span> <span class="op">)</span><span class="op">-&gt;</span> <span class="va">temp</span></span></span>
<span class="r-in"><span><span class="co"># temp is now a tapered 3X10 cross covariance matrix in sparse format. </span></span></span>
<span class="r-in"><span></span></span>
<span class="r-in"><span> <span class="fu">is.spam</span><span class="op">(</span> <span class="va">temp</span><span class="op">)</span>  <span class="co"># evaluates to TRUE</span></span></span>
<span class="r-out co"><span class="r-pr">#&gt;</span> [1] TRUE</span>
<span class="r-in"><span></span></span>
<span class="r-in"><span><span class="co"># should be identical to</span></span></span>
<span class="r-in"><span><span class="co"># the direct matrix product</span></span></span>
<span class="r-in"><span></span></span>
<span class="r-in"><span> <span class="va">temp2</span><span class="op">&lt;-</span> <span class="fu">Exp.cov</span><span class="op">(</span> <span class="va">x</span><span class="op">[</span><span class="fl">1</span><span class="op">:</span><span class="fl">3</span>,<span class="op">]</span>,<span class="va">x</span><span class="op">[</span><span class="fl">1</span><span class="op">:</span><span class="fl">10</span>,<span class="op">]</span>, aRange<span class="op">=</span><span class="fl">1.5</span><span class="op">)</span> <span class="op">*</span> <span class="fu"><a href="Wendland.html">Wendland</a></span><span class="op">(</span><span class="fu"><a href="rdist.html">rdist</a></span><span class="op">(</span><span class="va">x</span><span class="op">[</span><span class="fl">1</span><span class="op">:</span><span class="fl">3</span>,<span class="op">]</span>,<span class="va">x</span><span class="op">[</span><span class="fl">1</span><span class="op">:</span><span class="fl">10</span>,<span class="op">]</span><span class="op">)</span>, </span></span>
<span class="r-in"><span>                      aRange<span class="op">=</span> <span class="fl">2.0</span>, k<span class="op">=</span><span class="fl">2</span>, dimension<span class="op">=</span><span class="fl">2</span><span class="op">)</span></span></span>
<span class="r-in"><span> <span class="fu"><a href="fields.tests.html">test.for.zero</a></span><span class="op">(</span>  <span class="fu"><a href="https://rdrr.io/r/base/matrix.html" class="external-link">as.matrix</a></span><span class="op">(</span><span class="va">temp</span><span class="op">)</span>, <span class="va">temp2</span><span class="op">)</span></span></span>
<span class="r-out co"><span class="r-pr">#&gt;</span> PASSED test at tolerance  1e-08</span>
<span class="r-in"><span></span></span>
<span class="r-in"><span><span class="co"># Testing that the "V" option works as advertized ...</span></span></span>
<span class="r-in"><span><span class="va">x1</span><span class="op">&lt;-</span> <span class="va">x</span><span class="op">[</span><span class="fl">1</span><span class="op">:</span><span class="fl">20</span>,<span class="op">]</span></span></span>
<span class="r-in"><span><span class="va">x2</span><span class="op">&lt;-</span> <span class="va">x</span><span class="op">[</span><span class="fl">1</span><span class="op">:</span><span class="fl">10</span>,<span class="op">]</span></span></span>
<span class="r-in"><span></span></span>
<span class="r-in"><span><span class="va">V</span><span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/matrix.html" class="external-link">matrix</a></span><span class="op">(</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="fl">2</span>,<span class="fl">1</span>,<span class="fl">0</span>,<span class="fl">4</span><span class="op">)</span>, <span class="fl">2</span>,<span class="fl">2</span><span class="op">)</span></span></span>
<span class="r-in"><span><span class="va">Vi</span><span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/solve.html" class="external-link">solve</a></span><span class="op">(</span> <span class="va">V</span><span class="op">)</span></span></span>
<span class="r-in"><span></span></span>
<span class="r-in"><span><span class="va">u1</span><span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/t.html" class="external-link">t</a></span><span class="op">(</span><span class="va">Vi</span><span class="op"><a href="https://rdrr.io/r/base/matmult.html" class="external-link">%*%</a></span> <span class="fu"><a href="https://rdrr.io/r/base/t.html" class="external-link">t</a></span><span class="op">(</span><span class="va">x1</span><span class="op">)</span><span class="op">)</span></span></span>
<span class="r-in"><span><span class="va">u2</span><span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/t.html" class="external-link">t</a></span><span class="op">(</span><span class="va">Vi</span><span class="op"><a href="https://rdrr.io/r/base/matmult.html" class="external-link">%*%</a></span> <span class="fu"><a href="https://rdrr.io/r/base/t.html" class="external-link">t</a></span><span class="op">(</span><span class="va">x2</span><span class="op">)</span><span class="op">)</span></span></span>
<span class="r-in"><span></span></span>
<span class="r-in"><span><span class="va">look</span><span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/Log.html" class="external-link">exp</a></span><span class="op">(</span><span class="op">-</span><span class="fl">1</span><span class="op">*</span><span class="fu"><a href="rdist.html">rdist</a></span><span class="op">(</span><span class="va">u1</span>,<span class="va">u2</span><span class="op">)</span><span class="op">)</span></span></span>
<span class="r-in"><span><span class="va">look2</span><span class="op">&lt;-</span> <span class="fu">stationary.cov</span><span class="op">(</span> <span class="va">x1</span>,<span class="va">x2</span>, V<span class="op">=</span> <span class="va">V</span><span class="op">)</span></span></span>
<span class="r-in"><span><span class="fu"><a href="fields.tests.html">test.for.zero</a></span><span class="op">(</span> <span class="va">look</span>, <span class="va">look2</span><span class="op">)</span></span></span>
<span class="r-out co"><span class="r-pr">#&gt;</span> PASSED test at tolerance  1e-08</span>
<span class="r-in"><span></span></span>
<span class="r-in"><span></span></span>
<span class="r-in"><span><span class="co"># Here is an example of how the cross covariance multiply works</span></span></span>
<span class="r-in"><span><span class="co"># and lots of options on the arguments</span></span></span>
<span class="r-in"><span></span></span>
<span class="r-in"><span></span></span>
<span class="r-in"><span> <span class="va">Ctest</span><span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/stats/Normal.html" class="external-link">rnorm</a></span><span class="op">(</span><span class="fl">10</span><span class="op">)</span></span></span>
<span class="r-in"><span> </span></span>
<span class="r-in"><span> <span class="va">temp</span><span class="op">&lt;-</span> <span class="fu">stationary.cov</span><span class="op">(</span> <span class="va">x</span>,<span class="va">x</span><span class="op">[</span><span class="fl">1</span><span class="op">:</span><span class="fl">10</span>,<span class="op">]</span>, C<span class="op">=</span> <span class="va">Ctest</span>, </span></span>
<span class="r-in"><span>        Covariance<span class="op">=</span> <span class="st">"Wendland"</span>, </span></span>
<span class="r-in"><span>            k<span class="op">=</span><span class="fl">2</span>, dimension<span class="op">=</span><span class="fl">2</span>, aRange<span class="op">=</span><span class="fl">1.5</span> <span class="op">)</span></span></span>
<span class="r-in"><span></span></span>
<span class="r-in"><span><span class="co"># do multiply explicitly</span></span></span>
<span class="r-in"><span></span></span>
<span class="r-in"><span> <span class="va">temp2</span><span class="op">&lt;-</span> <span class="fu">stationary.cov</span><span class="op">(</span> <span class="va">x</span>,<span class="va">x</span><span class="op">[</span><span class="fl">1</span><span class="op">:</span><span class="fl">10</span>,<span class="op">]</span>,</span></span>
<span class="r-in"><span>        Covariance<span class="op">=</span> <span class="st">"Wendland"</span>,</span></span>
<span class="r-in"><span>            k<span class="op">=</span><span class="fl">2</span>, dimension<span class="op">=</span><span class="fl">2</span>, aRange<span class="op">=</span><span class="fl">1.5</span> <span class="op">)</span><span class="op"><a href="https://rdrr.io/r/base/matmult.html" class="external-link">%*%</a></span> <span class="va">Ctest</span></span></span>
<span class="r-in"><span></span></span>
<span class="r-in"><span> <span class="fu"><a href="fields.tests.html">test.for.zero</a></span><span class="op">(</span> <span class="va">temp</span>, <span class="va">temp2</span><span class="op">)</span></span></span>
<span class="r-out co"><span class="r-pr">#&gt;</span> PASSED test at tolerance  1e-08</span>
<span class="r-in"><span></span></span>
<span class="r-in"><span></span></span>
<span class="r-in"><span><span class="co"># use the tapered stationary version </span></span></span>
<span class="r-in"><span><span class="co"># cov.args is part of the argument list passed to stationary.taper.cov</span></span></span>
<span class="r-in"><span><span class="co"># within Krig. </span></span></span>
<span class="r-in"><span><span class="co"># This example needs the spam package.</span></span></span>
<span class="r-in"><span><span class="co"># </span></span></span>
<span class="r-in"><span></span></span>
<span class="r-in"><span><span class="kw">if</span> <span class="op">(</span><span class="cn">FALSE</span><span class="op">)</span> <span class="op">{</span></span></span>
<span class="r-in"><span></span></span>
<span class="r-in"><span><span class="fu"><a href="Krig.html">Krig</a></span><span class="op">(</span><span class="va">x</span>,<span class="va">y</span>, cov.function <span class="op">=</span> <span class="st">"stationary.taper.cov"</span>, aRange<span class="op">=</span><span class="fl">1.5</span>,</span></span>
<span class="r-in"><span>      cov.args<span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/list.html" class="external-link">list</a></span><span class="op">(</span>Taper.args<span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/list.html" class="external-link">list</a></span><span class="op">(</span>k<span class="op">=</span><span class="fl">2</span>, dimension<span class="op">=</span><span class="fl">2</span>,aRange<span class="op">=</span><span class="fl">2.0</span><span class="op">)</span> <span class="op">)</span></span></span>
<span class="r-in"><span>           <span class="op">)</span> <span class="op">-&gt;</span> <span class="va">out2</span> </span></span>
<span class="r-in"><span><span class="co"># NOTE: Wendland is the default taper here. </span></span></span>
<span class="r-in"><span><span class="op">}</span></span></span>
<span class="r-in"><span></span></span>
<span class="r-in"><span><span class="co"># BTW  this is very similar to </span></span></span>
<span class="r-in"><span><span class="kw">if</span> <span class="op">(</span><span class="cn">FALSE</span><span class="op">)</span> <span class="op">{</span></span></span>
<span class="r-in"><span> <span class="fu"><a href="Krig.html">Krig</a></span><span class="op">(</span><span class="va">x</span>,<span class="va">y</span>, aRange<span class="op">=</span> <span class="fl">1.5</span><span class="op">)</span><span class="op">-&gt;</span> <span class="va">out</span></span></span>
<span class="r-in"><span><span class="op">}</span></span></span>
<span class="r-in"><span></span></span>
<span class="r-in"><span></span></span>
<span class="r-in"><span></span></span>
</code></pre></div>
    </div>
  </div>
  <div class="col-md-3 hidden-xs hidden-sm" id="pkgdown-sidebar">
    <nav id="toc" data-toggle="toc" class="sticky-top"><h2 data-toc-skip>Contents</h2>
    </nav></div>
</div>


      <footer><div class="copyright">
  <p></p><p>Developed by Douglas Nychka, Reinhard Furrer, John Paige, Stephan Sain, Florian Gerber, Matthew Iverson.</p>
</div>

<div class="pkgdown">
  <p></p><p>Site built with <a href="https://pkgdown.r-lib.org/" class="external-link">pkgdown</a> 2.0.7.</p>
</div>

      </footer></div>

  


  

  </body></html>

